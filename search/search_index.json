{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"\ud83d\udc33 Docker Kubernetes Helm Desafio","title":"Home"},{"location":"desafio/","text":"Desafio Objetivo Implantar uma aplica\u00e7\u00e3o web em um cluster Kubernetes (KIND) usando o Docker e o Helm. Passos 1. Subir um banco de dados PostgreSQL O banco deve possuir um volume para persist\u00eancia dos dados. 2. Conectar uma aplica\u00e7\u00e3o ao banco de dados Apos subir o banco Postgres, tente conectar o projeto django que est\u00e1 no diret\u00f3rio desafio deste projeto. 3. Containerize a aplica\u00e7\u00e3o Containerize sua aplica\u00e7\u00e3o Django criando um Dockerfile . 4. Crie um docker-compose Crie um docker-compose com o service da aplica\u00e7\u00e3o e do banco de dados; Certifique-se de adicionar a depend\u00eancia do banco no service da aplica\u00e7\u00e3o; Confirme que sua aplica\u00e7\u00e3o consegue acessar o banco de dados; Remova as vari\u00e1veis de ambiente sens\u00edveis do c\u00f3digo. 5. Crie um cluster Kubernetes Configure um cluster Kubernetes local usando Kind com no m\u00ednimo 3 nodes; Certifique-se de que o cluster esteja pronto para receber implanta\u00e7\u00f5es. 6. Realize a instala\u00e7\u00e3o do Kubernetes Dashboard no seu cluster Voc\u00ea tamb\u00e9m precisar\u00e1 criar uma service-account e um cluster-role-binding ; Crie um token de acesso para a dashboard. 7. Empacote sua aplica\u00e7\u00e3o utilizando Helm Crie um Chart Helm para o deploy da sua aplica\u00e7\u00e3o, e configure os valores padr\u00e3o no arquivo values.yaml ; Lembre de manter o pod do banco de dados separado do pod da aplica\u00e7\u00e3o; utilize o par\u00e2metro --set ao instalar o chart helm para sobrescrever vari\u00e1veis sens\u00edveis do arquivo values.yaml ; Persista suas vari\u00e1veis atrav\u00e9s de secrets e configMaps ; Crie services para sua aplica\u00e7\u00e3o e banco; Crie um namespace para a sua aplica\u00e7\u00e3o 8. Teste sua aplica\u00e7\u00e3o usando Helm Fa\u00e7a uma pequena altera\u00e7\u00e3o na sua aplica\u00e7\u00e3o e fa\u00e7a update na implanta\u00e7\u00e3o usando o Helm Fa\u00e7a alguns testes utilizando a estrat\u00e9gia de deployment Recreate e RollingUpdate 9. Teste a escalabilidade Adicione escalabilidade horizontal criando novas replicas e um (HPA) para sua implanta\u00e7\u00e3o Adicione escalabilidade vertical definindo valores de request e limite para os resources da sua implanta\u00e7\u00e3o (HPA) - Horizontal Pod autoscaler 10. Execute um Registry localmente Crie um registry local utilizando Harbor ou Distribution Suba suas imagens para este registry e utilize-as no helm","title":"Desafio"},{"location":"desafio/#desafio","text":"","title":"Desafio"},{"location":"desafio/#objetivo","text":"Implantar uma aplica\u00e7\u00e3o web em um cluster Kubernetes (KIND) usando o Docker e o Helm.","title":"Objetivo"},{"location":"desafio/#passos","text":"","title":"Passos"},{"location":"desafio/#1-subir-um-banco-de-dados-postgresql","text":"O banco deve possuir um volume para persist\u00eancia dos dados.","title":"1. Subir um banco de dados PostgreSQL"},{"location":"desafio/#2-conectar-uma-aplicacao-ao-banco-de-dados","text":"Apos subir o banco Postgres, tente conectar o projeto django que est\u00e1 no diret\u00f3rio desafio deste projeto.","title":"2. Conectar uma aplica\u00e7\u00e3o ao banco de dados"},{"location":"desafio/#3-containerize-a-aplicacao","text":"Containerize sua aplica\u00e7\u00e3o Django criando um Dockerfile .","title":"3. Containerize a aplica\u00e7\u00e3o"},{"location":"desafio/#4-crie-um-docker-compose","text":"Crie um docker-compose com o service da aplica\u00e7\u00e3o e do banco de dados; Certifique-se de adicionar a depend\u00eancia do banco no service da aplica\u00e7\u00e3o; Confirme que sua aplica\u00e7\u00e3o consegue acessar o banco de dados; Remova as vari\u00e1veis de ambiente sens\u00edveis do c\u00f3digo.","title":"4. Crie um docker-compose"},{"location":"desafio/#5-crie-um-cluster-kubernetes","text":"Configure um cluster Kubernetes local usando Kind com no m\u00ednimo 3 nodes; Certifique-se de que o cluster esteja pronto para receber implanta\u00e7\u00f5es.","title":"5. Crie um cluster Kubernetes"},{"location":"desafio/#6-realize-a-instalacao-do-kubernetes-dashboard-no-seu-cluster","text":"Voc\u00ea tamb\u00e9m precisar\u00e1 criar uma service-account e um cluster-role-binding ; Crie um token de acesso para a dashboard.","title":"6. Realize a instala\u00e7\u00e3o do Kubernetes Dashboard no seu cluster"},{"location":"desafio/#7-empacote-sua-aplicacao-utilizando-helm","text":"Crie um Chart Helm para o deploy da sua aplica\u00e7\u00e3o, e configure os valores padr\u00e3o no arquivo values.yaml ; Lembre de manter o pod do banco de dados separado do pod da aplica\u00e7\u00e3o; utilize o par\u00e2metro --set ao instalar o chart helm para sobrescrever vari\u00e1veis sens\u00edveis do arquivo values.yaml ; Persista suas vari\u00e1veis atrav\u00e9s de secrets e configMaps ; Crie services para sua aplica\u00e7\u00e3o e banco; Crie um namespace para a sua aplica\u00e7\u00e3o","title":"7.  Empacote sua aplica\u00e7\u00e3o utilizando Helm"},{"location":"desafio/#8-teste-sua-aplicacao-usando-helm","text":"Fa\u00e7a uma pequena altera\u00e7\u00e3o na sua aplica\u00e7\u00e3o e fa\u00e7a update na implanta\u00e7\u00e3o usando o Helm Fa\u00e7a alguns testes utilizando a estrat\u00e9gia de deployment Recreate e RollingUpdate","title":"8. Teste sua aplica\u00e7\u00e3o usando Helm"},{"location":"desafio/#9-teste-a-escalabilidade","text":"Adicione escalabilidade horizontal criando novas replicas e um (HPA) para sua implanta\u00e7\u00e3o Adicione escalabilidade vertical definindo valores de request e limite para os resources da sua implanta\u00e7\u00e3o (HPA) - Horizontal Pod autoscaler","title":"9. Teste a escalabilidade"},{"location":"desafio/#10-execute-um-registry-localmente","text":"Crie um registry local utilizando Harbor ou Distribution Suba suas imagens para este registry e utilize-as no helm","title":"10. Execute um Registry localmente"},{"location":"docker/","text":"Docker Usando o Docker, podemos criar de forma consistente e autom\u00e1tica ambientes isolados e port\u00e1teis para aplica\u00e7\u00f5es. \ud83d\udc33 Install Docker O Docker fornece um script pratico em get.docker.com para instalar o Docker. Esse script n\u00e3o \u00e9 recomendado para ambientes produtivos 1 2 3 4 5 6 7 sudo -i curl -fsSL https://get.docker.com | bash systemctl enable docker systemctl restart docker docker ps Root privileges Por padr\u00e3o, o daemon do Docker faz bind em um socket Unix, e n\u00e3o em uma porta TCP. Sockets Unix, por sua vez, s\u00e3o de propriedade e de uso exclusivo do usu\u00e1rio root (por isso o Docker sempre \u00e9 iniciado como root). Para evitar o uso cont\u00ednuo do comando sudo ao rodar comandos Docker, utilize o grupo docker que \u00e9 criado durante a instala\u00e7\u00e3o e adicione o seu usu\u00e1rio a ele. Esse procedimento permite que o usu\u00e1rio tenha os mesmos privil\u00e9gios do usu\u00e1rio root em opera\u00e7\u00f5es relacionadas ao Docker. Mais informa\u00e7\u00f5es: https://docs.docker.com/engine/security/ . Para criar um grupo no Linux e adicionar um usu\u00e1rio: 1 sudo usermod -aG docker $(whoami) Interagindo com o container O docker \u00e9 acessado via terminal atrav\u00e9s do comando docker . Hello World O Docker disponibiliza uma imagem personalizada chamada \"hello-world\", que serve para testar a instala\u00e7\u00e3o e validar se tudo est\u00e1 funcionando conforme o esperado. Para executar um cont\u00eainer, utilizamos o par\u00e2metro run do comando docker . Exemplos: 1 2 3 4 5 # Execute um container hello-world: docker container run hello-world # Execute um container com Ubuntu: docker run -it ubuntu bash Docker RUN common parameters Utilizando o par\u00e2metro -d faz com que o container seja executado em background. -p : Publica/exp\u00f5e a(s) porta(s) de um cont\u00eainer para o host. -e : Define vari\u00e1veis de ambiente. -it : cria uma sess\u00e3o que permite a intera\u00e7\u00e3o em tempo real com o cont\u00eainer. -i : permite que voc\u00ea mantenha a entrada padr\u00e3o (stdin) aberta para interagir com o cont\u00eainer em tempo real. -t : aloca um pseudo-terminal para o cont\u00eainer, permitindo que voc\u00ea visualize a sa\u00edda do cont\u00eainer de forma formatada. Fluxo de cria\u00e7\u00e3o e execu\u00e7\u00e3o de um container: O cliente do Docker se comunica com o daemon do Docker. O daemon do Docker baixa a imagem do registro caso ela n\u00e3o exista no host. O daemon do Docker cria e executa um novo cont\u00eainer a partir da imagem definida. Basic usage 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 # Executa um container CentOS 7 e cria uma sess\u00e3o iterativa docker run -it centos:7 # (1) # Lista os containers em execu\u00e7\u00e3o docker ps # (2) # Pausa os containers em execu\u00e7\u00e3o docker pause <container-id/container-name> # Interrompe um container docker stop <container-id/container-name> # Interrompe todos os containers docker stop $( docker ps -qa ) # Inicia um container docker start <container-id/container-name> # Reinicia um container docker restart <container-id/container-name> # Visualizar o uso de recursos dos containers docker stats # Visualizar os logs de um container docker logs <container-id/container-name> # Inspecionar toda a configura\u00e7\u00e3o de um container # (3) docker inspect <container-id/container-name> # Delete/Remove um container parado docker rm <container-id/container-name> # (4) # Atualizar o valor limite de uso dos recursos do cont\u00eainer docker update -m 256m --cpus = 1 <container-id/container-name> # (5) Voc\u00ea pode usar qualquer outra imagem dispon\u00edvel no Docker Hub ou no seu registro privado. Use a op\u00e7\u00e3o -a/-all para listar at\u00e9 mesmo os cont\u00eaineres parados. O comando \"inspect\" \u00e9 extremamente \u00fatil para depura\u00e7\u00e3o. Quando um cont\u00eainer \u00e9 exclu\u00eddo, a imagem permanece no host. Por padr\u00e3o, o cont\u00eainer n\u00e3o tem limite de recursos. Use docker update --help para verificar as op\u00e7\u00f5es dispon\u00edveis. Isso funciona mesmo para cont\u00eaineres em execu\u00e7\u00e3o. Dockerfile O Dockerfile \u00e9 um arquivo de configura\u00e7\u00e3o usado para definir e construir imagens de cont\u00eaineres Docker. Nele, voc\u00ea pode especificar a imagem base, as depend\u00eancias, as vari\u00e1veis de ambiente e os comandos necess\u00e1rios para construir uma imagem de cont\u00eainer Docker para o seu projeto. Getting started Para iniciar, voc\u00ea apenas precisa criar o arquivo: Dockerfile Dockerfile 1 2 3 mkdir /home/cloud-native/ cd /home/cloud-native/ touch Dockerfile Edite seu arquivo com as seguintes instru\u00e7\u00f5es: 1 nano Dockerfile 1 2 3 4 5 FROM nginx RUN /bin/echo \"HELLO FROM INSTRUCT CLOUD-NATIVE!!!\" > /usr/share/nginx/html/index.html CMD [ \"nginx\" , \"-g\" , \"daemon off;\" ] Execute o comando docker build para criar uma imagem usando o Dockerfile . 1 docker build -t cloud-native:1.0 . 1 2 3 4 5 6 7 8 9 10 11 12 [ + ] Building 0 .7s ( 6 /6 ) FINISHED = > [ internal ] load build definition from Dockerfile 0 .0s = > = > transferring dockerfile: 37B 0 .0s = > [ internal ] load .dockerignore 0 .0s = > = > transferring context: 2B 0 .0s = > [ internal ] load metadata for docker.io/library/ubuntu:latest 0 .6s = > [ 1 /2 ] FROM docker.io/library/ubuntu@sha256:ac5822fa348fd7.... 0 .0s = > CACHED [ 2 /2 ] RUN /bin/echo \"HELLO FROM INSTRUCT CLOUD-NATIVE\" 0 .0s = > exporting to image 0 .0s = > = > exporting layers 0 .0s = > = > writing image sha256:ede41435957b1a79925c3595759b11a6a... 0 .0s = > = > naming to docker.io/library/cloud-native 0 .0s 1 docker run -d -p 80 :80 cloud-native:1.0 Esse comando ir\u00e1 executar um container utilizando a imagem gerada pelo Dockerfile que voc\u00ea criou, e ent\u00e3o voc\u00ea poder\u00e1 ver uma mensagem no seu localhost Dockerfile Instruct ions Comando dispon\u00edveis na cria\u00e7\u00e3o de um Dockerfile: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 FROM : - Especifica a imagem base para o Dockerfile. - Deve ser a primeira linha do Dockerfile. USER: - Determina qual usu\u00e1rio ser\u00e1 usado na imagem. Por padr\u00e3o, \u00e9 o usu\u00e1rio root. WORKDIR: - Altera o diret\u00f3rio de trabalho dentro do cont\u00eainer. - O padr\u00e3o \u00e9 \"/\" ( raiz ) . COPY: - Copia arquivos e diret\u00f3rios para o sistema de arquivos do cont\u00eainer. ADD: - Copia diret\u00f3rios e arquivos locais ou remotos para o sistema de arquivos do cont\u00eainer. ENV: - Define vari\u00e1veis de ambiente para o cont\u00eainer. VOLUME: - Cria um ponto de montagem para armazenar dados persistentes. RUN: - Executa qualquer comando em uma nova camada em cima da imagem. EXPOSE: - Informa em qual ( is ) porta ( s ) o cont\u00eainer ir\u00e1 escutar. CMD: - Especifica o comando padr\u00e3o a ser executado quando o cont\u00eainer \u00e9 iniciado. ENTRYPOINT: - Configura o cont\u00eainer para executar um execut\u00e1vel espec\u00edfico. Quando finalizado, o cont\u00eainer tamb\u00e9m ser\u00e1 interrompido. Compartilhando imagens At\u00e9 ent\u00e3o, estamos utilizando o registry Docker Hub para obter as imagens. Para enviar uma imagem para o Docker Hub: Isso tornar\u00e1 sua imagem disponivel para download para outros usuarios. Crie uma conta no Docker Hub Fa\u00e7a login com usu\u00e1rio e senha executando: 1 docker login Crie sua imagem usando o Dockerfile que voc\u00ea criou anteriormente, utilizando uma tag: 1 docker build <your-username>/cloud-native:1.0 Envie sua imagem para o docker hub registry executando: 1 docker push <your-username>/cloud-native:1.0 E \u00e9 isso, sua imagem agora est\u00e1 dispon\u00edvel no docker hub!!. Criando meu pr\u00f3prio registry Embora o Docker Hub seja um registry p\u00fablico confiavel, existem casos em que empresas podem optar por n\u00e3o utiliz\u00e1-lo e preferir um registry interno, como o Harbor !. Registries internos fornecem um maior controle sobre a seguran\u00e7a, privacidade, conformidade, melhor desempenho e menor lat\u00eancia. Criando um registry Distribution 1 2 3 4 5 6 7 8 # Crie e execute um registry `Distribution` utilizando docker: docker container run -d -p 5000 :5000 --restart = always --name registry registry # Adicione uma Tag a sua imagem: docker tag <image-id> localhost:5000/<tag> # (1) # Envie sua imagem para seu registry privado: docker push localhost:5000/<tag> Ao buildar uma imagem, o docker gera um id que \u00e9 vis\u00edvel no output do comando! Outros registries populares: Amazon Elastic Container Registry (ECR) Azure Container Registry (ACR) Google Artifact Registry GitLab Container Registry Harbor Quay Docker-compose O Docker Compose \u00e9 uma ferramenta para definir e gerenciar v\u00e1rios cont\u00eaineres Docker como uma \u00fanica aplica\u00e7\u00e3o, facilitando a configura\u00e7\u00e3o, execu\u00e7\u00e3o e escalabilidade de servi\u00e7os atrav\u00e9s de um \u00fanico arquivo YAML. Getting started Para iniciar, voc\u00ea apenas precisa criar o arquivo: docker-compose.yaml 1 nano docker-compose.yaml Edite seu arquivo com as seguintes instru\u00e7\u00f5es: docker-compose.yaml 1 2 3 4 5 6 7 version : \"3.9\" services : web : image : nginx ports : - \"8022:80\" para utilizar o docker-compose, execute: 1 docker-compose up -d # (1) Se for necess\u00e1rio fazer o build de alguma imagem, voc\u00ea pode adicionar o par\u00e2metro --build Esse docker-compose conta com uma configura\u00e7\u00e3o minima: Uma network \u00e9 criada por padr\u00e3o para garantir a conex\u00e3o entre os containers cria um service chamado web utilizando a imagem do nginx exp\u00f5e o servi\u00e7o na porta 8022 do host Turbinando o docker-compose Adicionando um novo service Vamos adicionar um postgreSQL ao docker-compose : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 version : \"3\" services : web : container_name : nginx-web build : context : ./Dockerfile # target: <stage-name> # (2) ports : - \"8022:80\" db : image : postgres:12.1 container_name : database ports : - \"5434:5432\" volumes : - ./postgres:/var/lib/postgresql/data # (1) /var/lib/postgresql/data \u00e9 o diret\u00f3rio onde os dados ficam armazenados no postgreSQL adicione um target se estiver utilizando multi-stage build Altera\u00e7\u00f5es: 1 2 3 4 - Utiliza o ` Dockerfile ` do diret\u00f3rio para buildar a imagem - Nomeia os containers atraves da chave container_name - Adiciona um banco de dados postgreSQL exposto na porta ` 5432 ` : - Adiciona um volume para persistir os dados do banco # (1) Este volume persiste os dados do container postgres na pasta /postgres do host. Adicionando vari\u00e1veis de ambiente 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 version : \"3.9\" services : web : container_name : nginx-web build : context : ./Dockerfile # target: <stage-name> (1) ports : - \"8022:80\" db : image : postgres:12.1 container_name : database ports : - \"5434:5432\" volumes : - ./postgres:/docker-entrypoint-initdb.d env_file : .env # (2) environment : POSTGRES_USER : postgres POSTGRES_PASSWORD : postgres POSTGRES_DB : cloud-native adicione um target se estiver utilizando multi-stage build \u00c9 nescessario que exista o arquivo .env Podemos adicionar vari\u00e1veis de ambiente no servi\u00e7o adicionando a chave environment e/ou env_file Adicionando recursos 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 version : \"3.9\" services : web : image : nginx ports : - \"8022:80\" db : image : postgres:12.1 deploy : # (1) resources : limits : cpus : '0.5' memory : '512M' reservations : cpus : '0.2' memory : '256M' ports : - \"5434:5432\" volumes : - ./postgres:/docker-entrypoint-initdb.d env_file : .env environment : POSTGRES_USER : postgres POSTGRES_PASSWORD : postgres POSTGRES_DB : cloud-native Par\u00e2metros da chave deploy funcionam apenas ao utilizar docker swarm , exceto pelo resources . Os par\u00e2metros da chave deploy funcionam apenas ao utilizar docker swarm , valores setados s\u00e3o ignorados pelo docker-compose up , exceto pela chave resources . Boas praticas usando Docker Use imagens oficiais e verificadas sempre que poss\u00edvel B\u00e1sico Em vez de usar uma imagem base do sistema operacional e instalar o node.js , npm e outras ferramentas necess\u00e1rias para sua aplica\u00e7\u00e3o, utilize a imagem oficial do node para sua aplica\u00e7\u00e3o. Se voc\u00ea tiver v\u00e1rias imagens com muitos elementos em comum, considere criar a sua pr\u00f3pria base image Fa\u00e7a uso do arquivo .dockerignore para manter apenas os arquivos necess\u00e1rios no container N\u00e3o utilize a tag latest em produ\u00e7\u00e3o Persista seus dados usando volumes Fa\u00e7a uso de Multi-stage build Voc\u00ea pode ter m\u00faltiplas instru\u00e7\u00f5es FROM no seu Dockerfile, cada uma inicia um novo estagio do build Voc\u00ea poder\u00e1 seletivamente copiar artefatos de um estagio para outro permitir\u00e1 voc\u00ea deixar para tr\u00e1s tudo o que voc\u00ea n\u00e3o quiser na imagem final Voc\u00ea pode especificar um target para o build executando: docker build --target <stage> O par\u00e2metro target est\u00e1 dispon\u00edvel no build do seu servi\u00e7o no docker-compose.yaml 1 2 3 4 5 6 services : service_name : build : image : python:3.9 target : dev ... Nomeie os est\u00e1gios do seu build Evite utilizar imagens do Alpine Usar Alpine para obter imagens menores \u00e9 poss\u00edvel, mas vem com alguns desafios: Avaliar os compiladores necess\u00e1rios e os cabe\u00e7alhos das bibliotecas Ter um profundo entendimento da constru\u00e7\u00e3o de imagens Docker com multi-stage builds Quando um projeto Python \u00e9 implantado, N\u00c3O \u00c9 RECOMENDADO usar imagens Alpine como base. Sem os cabe\u00e7alhos das bibliotecas necess\u00e1rias, o container n\u00e3o vai buildar Sem conhecimento sobre como as camadas e est\u00e1gios do Docker funcionam, a imagem final pode ser maior do que uma imagem produzida sem Alpine devido a ferramentas de compila\u00e7\u00e3o desnecess\u00e1rias na imagem final.","title":"Docker"},{"location":"docker/#docker","text":"Usando o Docker, podemos criar de forma consistente e autom\u00e1tica ambientes isolados e port\u00e1teis para aplica\u00e7\u00f5es.","title":"Docker"},{"location":"docker/#install-docker","text":"O Docker fornece um script pratico em get.docker.com para instalar o Docker. Esse script n\u00e3o \u00e9 recomendado para ambientes produtivos 1 2 3 4 5 6 7 sudo -i curl -fsSL https://get.docker.com | bash systemctl enable docker systemctl restart docker docker ps","title":"\ud83d\udc33 Install Docker"},{"location":"docker/#root-privileges","text":"Por padr\u00e3o, o daemon do Docker faz bind em um socket Unix, e n\u00e3o em uma porta TCP. Sockets Unix, por sua vez, s\u00e3o de propriedade e de uso exclusivo do usu\u00e1rio root (por isso o Docker sempre \u00e9 iniciado como root). Para evitar o uso cont\u00ednuo do comando sudo ao rodar comandos Docker, utilize o grupo docker que \u00e9 criado durante a instala\u00e7\u00e3o e adicione o seu usu\u00e1rio a ele. Esse procedimento permite que o usu\u00e1rio tenha os mesmos privil\u00e9gios do usu\u00e1rio root em opera\u00e7\u00f5es relacionadas ao Docker. Mais informa\u00e7\u00f5es: https://docs.docker.com/engine/security/ . Para criar um grupo no Linux e adicionar um usu\u00e1rio: 1 sudo usermod -aG docker $(whoami)","title":"Root privileges"},{"location":"docker/#interagindo-com-o-container","text":"O docker \u00e9 acessado via terminal atrav\u00e9s do comando docker .","title":"Interagindo com o container"},{"location":"docker/#hello-world","text":"O Docker disponibiliza uma imagem personalizada chamada \"hello-world\", que serve para testar a instala\u00e7\u00e3o e validar se tudo est\u00e1 funcionando conforme o esperado. Para executar um cont\u00eainer, utilizamos o par\u00e2metro run do comando docker . Exemplos: 1 2 3 4 5 # Execute um container hello-world: docker container run hello-world # Execute um container com Ubuntu: docker run -it ubuntu bash Docker RUN common parameters Utilizando o par\u00e2metro -d faz com que o container seja executado em background. -p : Publica/exp\u00f5e a(s) porta(s) de um cont\u00eainer para o host. -e : Define vari\u00e1veis de ambiente. -it : cria uma sess\u00e3o que permite a intera\u00e7\u00e3o em tempo real com o cont\u00eainer. -i : permite que voc\u00ea mantenha a entrada padr\u00e3o (stdin) aberta para interagir com o cont\u00eainer em tempo real. -t : aloca um pseudo-terminal para o cont\u00eainer, permitindo que voc\u00ea visualize a sa\u00edda do cont\u00eainer de forma formatada. Fluxo de cria\u00e7\u00e3o e execu\u00e7\u00e3o de um container: O cliente do Docker se comunica com o daemon do Docker. O daemon do Docker baixa a imagem do registro caso ela n\u00e3o exista no host. O daemon do Docker cria e executa um novo cont\u00eainer a partir da imagem definida.","title":"Hello World"},{"location":"docker/#basic-usage","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 # Executa um container CentOS 7 e cria uma sess\u00e3o iterativa docker run -it centos:7 # (1) # Lista os containers em execu\u00e7\u00e3o docker ps # (2) # Pausa os containers em execu\u00e7\u00e3o docker pause <container-id/container-name> # Interrompe um container docker stop <container-id/container-name> # Interrompe todos os containers docker stop $( docker ps -qa ) # Inicia um container docker start <container-id/container-name> # Reinicia um container docker restart <container-id/container-name> # Visualizar o uso de recursos dos containers docker stats # Visualizar os logs de um container docker logs <container-id/container-name> # Inspecionar toda a configura\u00e7\u00e3o de um container # (3) docker inspect <container-id/container-name> # Delete/Remove um container parado docker rm <container-id/container-name> # (4) # Atualizar o valor limite de uso dos recursos do cont\u00eainer docker update -m 256m --cpus = 1 <container-id/container-name> # (5) Voc\u00ea pode usar qualquer outra imagem dispon\u00edvel no Docker Hub ou no seu registro privado. Use a op\u00e7\u00e3o -a/-all para listar at\u00e9 mesmo os cont\u00eaineres parados. O comando \"inspect\" \u00e9 extremamente \u00fatil para depura\u00e7\u00e3o. Quando um cont\u00eainer \u00e9 exclu\u00eddo, a imagem permanece no host. Por padr\u00e3o, o cont\u00eainer n\u00e3o tem limite de recursos. Use docker update --help para verificar as op\u00e7\u00f5es dispon\u00edveis. Isso funciona mesmo para cont\u00eaineres em execu\u00e7\u00e3o.","title":"Basic usage"},{"location":"docker/#dockerfile","text":"O Dockerfile \u00e9 um arquivo de configura\u00e7\u00e3o usado para definir e construir imagens de cont\u00eaineres Docker. Nele, voc\u00ea pode especificar a imagem base, as depend\u00eancias, as vari\u00e1veis de ambiente e os comandos necess\u00e1rios para construir uma imagem de cont\u00eainer Docker para o seu projeto.","title":"Dockerfile"},{"location":"docker/#getting-started","text":"Para iniciar, voc\u00ea apenas precisa criar o arquivo: Dockerfile Dockerfile 1 2 3 mkdir /home/cloud-native/ cd /home/cloud-native/ touch Dockerfile Edite seu arquivo com as seguintes instru\u00e7\u00f5es: 1 nano Dockerfile 1 2 3 4 5 FROM nginx RUN /bin/echo \"HELLO FROM INSTRUCT CLOUD-NATIVE!!!\" > /usr/share/nginx/html/index.html CMD [ \"nginx\" , \"-g\" , \"daemon off;\" ] Execute o comando docker build para criar uma imagem usando o Dockerfile . 1 docker build -t cloud-native:1.0 . 1 2 3 4 5 6 7 8 9 10 11 12 [ + ] Building 0 .7s ( 6 /6 ) FINISHED = > [ internal ] load build definition from Dockerfile 0 .0s = > = > transferring dockerfile: 37B 0 .0s = > [ internal ] load .dockerignore 0 .0s = > = > transferring context: 2B 0 .0s = > [ internal ] load metadata for docker.io/library/ubuntu:latest 0 .6s = > [ 1 /2 ] FROM docker.io/library/ubuntu@sha256:ac5822fa348fd7.... 0 .0s = > CACHED [ 2 /2 ] RUN /bin/echo \"HELLO FROM INSTRUCT CLOUD-NATIVE\" 0 .0s = > exporting to image 0 .0s = > = > exporting layers 0 .0s = > = > writing image sha256:ede41435957b1a79925c3595759b11a6a... 0 .0s = > = > naming to docker.io/library/cloud-native 0 .0s 1 docker run -d -p 80 :80 cloud-native:1.0 Esse comando ir\u00e1 executar um container utilizando a imagem gerada pelo Dockerfile que voc\u00ea criou, e ent\u00e3o voc\u00ea poder\u00e1 ver uma mensagem no seu localhost","title":"Getting started"},{"location":"docker/#dockerfile-instructions","text":"Comando dispon\u00edveis na cria\u00e7\u00e3o de um Dockerfile: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 FROM : - Especifica a imagem base para o Dockerfile. - Deve ser a primeira linha do Dockerfile. USER: - Determina qual usu\u00e1rio ser\u00e1 usado na imagem. Por padr\u00e3o, \u00e9 o usu\u00e1rio root. WORKDIR: - Altera o diret\u00f3rio de trabalho dentro do cont\u00eainer. - O padr\u00e3o \u00e9 \"/\" ( raiz ) . COPY: - Copia arquivos e diret\u00f3rios para o sistema de arquivos do cont\u00eainer. ADD: - Copia diret\u00f3rios e arquivos locais ou remotos para o sistema de arquivos do cont\u00eainer. ENV: - Define vari\u00e1veis de ambiente para o cont\u00eainer. VOLUME: - Cria um ponto de montagem para armazenar dados persistentes. RUN: - Executa qualquer comando em uma nova camada em cima da imagem. EXPOSE: - Informa em qual ( is ) porta ( s ) o cont\u00eainer ir\u00e1 escutar. CMD: - Especifica o comando padr\u00e3o a ser executado quando o cont\u00eainer \u00e9 iniciado. ENTRYPOINT: - Configura o cont\u00eainer para executar um execut\u00e1vel espec\u00edfico. Quando finalizado, o cont\u00eainer tamb\u00e9m ser\u00e1 interrompido.","title":"Dockerfile Instructions"},{"location":"docker/#compartilhando-imagens","text":"At\u00e9 ent\u00e3o, estamos utilizando o registry Docker Hub para obter as imagens. Para enviar uma imagem para o Docker Hub: Isso tornar\u00e1 sua imagem disponivel para download para outros usuarios. Crie uma conta no Docker Hub Fa\u00e7a login com usu\u00e1rio e senha executando: 1 docker login Crie sua imagem usando o Dockerfile que voc\u00ea criou anteriormente, utilizando uma tag: 1 docker build <your-username>/cloud-native:1.0 Envie sua imagem para o docker hub registry executando: 1 docker push <your-username>/cloud-native:1.0 E \u00e9 isso, sua imagem agora est\u00e1 dispon\u00edvel no docker hub!!.","title":"Compartilhando imagens"},{"location":"docker/#criando-meu-proprio-registry","text":"Embora o Docker Hub seja um registry p\u00fablico confiavel, existem casos em que empresas podem optar por n\u00e3o utiliz\u00e1-lo e preferir um registry interno, como o Harbor !. Registries internos fornecem um maior controle sobre a seguran\u00e7a, privacidade, conformidade, melhor desempenho e menor lat\u00eancia. Criando um registry Distribution 1 2 3 4 5 6 7 8 # Crie e execute um registry `Distribution` utilizando docker: docker container run -d -p 5000 :5000 --restart = always --name registry registry # Adicione uma Tag a sua imagem: docker tag <image-id> localhost:5000/<tag> # (1) # Envie sua imagem para seu registry privado: docker push localhost:5000/<tag> Ao buildar uma imagem, o docker gera um id que \u00e9 vis\u00edvel no output do comando! Outros registries populares: Amazon Elastic Container Registry (ECR) Azure Container Registry (ACR) Google Artifact Registry GitLab Container Registry Harbor Quay","title":"Criando meu pr\u00f3prio registry"},{"location":"docker/#docker-compose","text":"O Docker Compose \u00e9 uma ferramenta para definir e gerenciar v\u00e1rios cont\u00eaineres Docker como uma \u00fanica aplica\u00e7\u00e3o, facilitando a configura\u00e7\u00e3o, execu\u00e7\u00e3o e escalabilidade de servi\u00e7os atrav\u00e9s de um \u00fanico arquivo YAML.","title":"Docker-compose"},{"location":"docker/#getting-started_1","text":"Para iniciar, voc\u00ea apenas precisa criar o arquivo: docker-compose.yaml 1 nano docker-compose.yaml Edite seu arquivo com as seguintes instru\u00e7\u00f5es: docker-compose.yaml 1 2 3 4 5 6 7 version : \"3.9\" services : web : image : nginx ports : - \"8022:80\" para utilizar o docker-compose, execute: 1 docker-compose up -d # (1) Se for necess\u00e1rio fazer o build de alguma imagem, voc\u00ea pode adicionar o par\u00e2metro --build Esse docker-compose conta com uma configura\u00e7\u00e3o minima: Uma network \u00e9 criada por padr\u00e3o para garantir a conex\u00e3o entre os containers cria um service chamado web utilizando a imagem do nginx exp\u00f5e o servi\u00e7o na porta 8022 do host","title":"Getting started"},{"location":"docker/#turbinando-o-docker-compose","text":"Adicionando um novo service Vamos adicionar um postgreSQL ao docker-compose : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 version : \"3\" services : web : container_name : nginx-web build : context : ./Dockerfile # target: <stage-name> # (2) ports : - \"8022:80\" db : image : postgres:12.1 container_name : database ports : - \"5434:5432\" volumes : - ./postgres:/var/lib/postgresql/data # (1) /var/lib/postgresql/data \u00e9 o diret\u00f3rio onde os dados ficam armazenados no postgreSQL adicione um target se estiver utilizando multi-stage build Altera\u00e7\u00f5es: 1 2 3 4 - Utiliza o ` Dockerfile ` do diret\u00f3rio para buildar a imagem - Nomeia os containers atraves da chave container_name - Adiciona um banco de dados postgreSQL exposto na porta ` 5432 ` : - Adiciona um volume para persistir os dados do banco # (1) Este volume persiste os dados do container postgres na pasta /postgres do host. Adicionando vari\u00e1veis de ambiente 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 version : \"3.9\" services : web : container_name : nginx-web build : context : ./Dockerfile # target: <stage-name> (1) ports : - \"8022:80\" db : image : postgres:12.1 container_name : database ports : - \"5434:5432\" volumes : - ./postgres:/docker-entrypoint-initdb.d env_file : .env # (2) environment : POSTGRES_USER : postgres POSTGRES_PASSWORD : postgres POSTGRES_DB : cloud-native adicione um target se estiver utilizando multi-stage build \u00c9 nescessario que exista o arquivo .env Podemos adicionar vari\u00e1veis de ambiente no servi\u00e7o adicionando a chave environment e/ou env_file Adicionando recursos 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 version : \"3.9\" services : web : image : nginx ports : - \"8022:80\" db : image : postgres:12.1 deploy : # (1) resources : limits : cpus : '0.5' memory : '512M' reservations : cpus : '0.2' memory : '256M' ports : - \"5434:5432\" volumes : - ./postgres:/docker-entrypoint-initdb.d env_file : .env environment : POSTGRES_USER : postgres POSTGRES_PASSWORD : postgres POSTGRES_DB : cloud-native Par\u00e2metros da chave deploy funcionam apenas ao utilizar docker swarm , exceto pelo resources . Os par\u00e2metros da chave deploy funcionam apenas ao utilizar docker swarm , valores setados s\u00e3o ignorados pelo docker-compose up , exceto pela chave resources .","title":"Turbinando o docker-compose"},{"location":"docker/#boas-praticas-usando-docker","text":"Use imagens oficiais e verificadas sempre que poss\u00edvel","title":"Boas praticas usando Docker"},{"location":"docker/#basico","text":"Em vez de usar uma imagem base do sistema operacional e instalar o node.js , npm e outras ferramentas necess\u00e1rias para sua aplica\u00e7\u00e3o, utilize a imagem oficial do node para sua aplica\u00e7\u00e3o. Se voc\u00ea tiver v\u00e1rias imagens com muitos elementos em comum, considere criar a sua pr\u00f3pria base image Fa\u00e7a uso do arquivo .dockerignore para manter apenas os arquivos necess\u00e1rios no container N\u00e3o utilize a tag latest em produ\u00e7\u00e3o Persista seus dados usando volumes","title":"B\u00e1sico"},{"location":"docker/#faca-uso-de-multi-stage-build","text":"Voc\u00ea pode ter m\u00faltiplas instru\u00e7\u00f5es FROM no seu Dockerfile, cada uma inicia um novo estagio do build Voc\u00ea poder\u00e1 seletivamente copiar artefatos de um estagio para outro permitir\u00e1 voc\u00ea deixar para tr\u00e1s tudo o que voc\u00ea n\u00e3o quiser na imagem final Voc\u00ea pode especificar um target para o build executando: docker build --target <stage> O par\u00e2metro target est\u00e1 dispon\u00edvel no build do seu servi\u00e7o no docker-compose.yaml 1 2 3 4 5 6 services : service_name : build : image : python:3.9 target : dev ... Nomeie os est\u00e1gios do seu build","title":"Fa\u00e7a uso de Multi-stage build"},{"location":"docker/#evite-utilizar-imagens-do-alpine","text":"Usar Alpine para obter imagens menores \u00e9 poss\u00edvel, mas vem com alguns desafios: Avaliar os compiladores necess\u00e1rios e os cabe\u00e7alhos das bibliotecas Ter um profundo entendimento da constru\u00e7\u00e3o de imagens Docker com multi-stage builds Quando um projeto Python \u00e9 implantado, N\u00c3O \u00c9 RECOMENDADO usar imagens Alpine como base. Sem os cabe\u00e7alhos das bibliotecas necess\u00e1rias, o container n\u00e3o vai buildar Sem conhecimento sobre como as camadas e est\u00e1gios do Docker funcionam, a imagem final pode ser maior do que uma imagem produzida sem Alpine devido a ferramentas de compila\u00e7\u00e3o desnecess\u00e1rias na imagem final.","title":"Evite utilizar imagens do Alpine"},{"location":"helm/","text":"Helm Helm \u00e9 um gerenciador de pacotes popular para Kubernetes que ajuda voc\u00ea a empacotar, implantar e gerenciar aplicativos. Helm Installation 1 2 3 curl -fsSL -o get_helm.sh https://raw.githubusercontent.com/helm/helm/main/scripts/get-helm-3 chmod 700 get_helm.sh ./get_helm.sh Using Helm Charts Requirements Kind Cluster Running Disponibilizando um reposit\u00f3rio de charts: 1 2 3 4 5 6 7 8 helm repo add bitnami https://charts.bitnami.com/bitnami helm repo update # List of available charts: helm search repo bitnami # Show Chart details: helm show chart bitnami/mysql Depois de instalado, voc\u00ea poder\u00e1 listar os charts que pode instalar: 1 helm search repo bitnami 1 2 3 4 5 6 NAME CHART VERSION APP VERSION DESCRIPTION bitnami/bitnami-common 0.0.9 0.0.9 DEPRECATED Chart with custom ... bitnami/airflow 8.0.2 2.0.0 Apache Airflow is a platform ... bitnami/apache 8.2.3 2.4.46 Chart for Apache HTTP Server bitnami/aspnet-core 1.2.3 3.1.9 ASP.NET Core is a framework ... # ... and many more Deploying a chart instalando um chart do reposit\u00f3rio da bitnami : 1 helm install bitnami/mysql --generate-name 1 2 3 4 5 6 7 NAME: mysql-1612624192 LAST DEPLOYED: Sat Feb 6 16:09:56 2021 NAMESPACE: default STATUS: deployed REVISION: 1 TEST SUITE: None NOTES: ... Removendo o chart instalando anteriormente: 1 helm uninstall mysql-1617481683 Helm basic usage Check Helm commands oficial documentation 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 # Cria um novo Chart helm create <chart-name> # Instala um pacote em um cluster Kubernetes. helm install <chart-name> ./<chart-folder> # Atualiza um pacote que j\u00e1 est\u00e1 instalado. helm upgrade <chart-name> ./<chart-folder> # Desinstala um pacote de um cluster Kubernetes. helm uninstall <chart-name> # Lista todos os pacotes instalados em um cluster Kubernetes. helm list # Mostra o status de um pacote instalado em um cluster Kubernetes. helm status <chart-name> # Mostra informa\u00e7\u00f5es detalhadas sobre um pacote do Helm. helm show chart ./<chart-folder> # Adiciona um reposit\u00f3rio de Helm charts. helm repo add stable https://charts.helm.sh/stable # Atualiza os reposit\u00f3rios do Helm. helm repo update # Pesquisa por pacotes dispon\u00edveis em reposit\u00f3rios. helm search repo # Verifica a validade de um pacote do Helm. helm lint ./<chart-folder> # Empacota um diret\u00f3rio em um arquivo .tgz. helm package ./<chart-folder> # Instala um plugin do Helm. helm plugin add https://github.com/databus23/helm-diff # Lista todos os plugins instalados. helm plugin list # Atualiza um plugin do Helm. helm plugin update diff Empacotando sua aplica\u00e7\u00e3o usando Helm Para empacotar sua aplica\u00e7\u00e3o, voc\u00ea s\u00f3 precisa navegar at\u00e9 o diret\u00f3rio raiz do sua aplica\u00e7\u00e3o e criar um Chart Helm executando o comando helm create Isso criar\u00e1 uma nova estrutura de diret\u00f3rio que cont\u00e9m modelos, valores e outros arquivos de configura\u00e7\u00e3o. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 cloud-native/ \u251c\u2500\u2500 Chart.yaml \u251c\u2500\u2500 charts \u251c\u2500\u2500 templates \u2502 \u251c\u2500\u2500 NOTES.txt \u2502 \u251c\u2500\u2500 _helpers.tpl \u2502 \u251c\u2500\u2500 deployment.yaml \u2502 \u251c\u2500\u2500 hpa.yaml \u2502 \u251c\u2500\u2500 ingress.yaml \u2502 \u251c\u2500\u2500 service.yaml \u2502 \u251c\u2500\u2500 serviceaccount.yaml \u2502 \u2514\u2500\u2500 tests \u2502 \u2514\u2500\u2500 test-connection.yaml \u2514\u2500\u2500 values.yaml Agora basta modificar os arquivos gerados no diret\u00f3rio do Chart: Modifique o arquivo Chart.yaml para fornecer metadados sobre seu Chart Personalize o arquivo values.yaml para definir vari\u00e1veis \u200b\u200be valores padr\u00e3o para sua aplica\u00e7\u00e3o. Personalize os manifestos do Kubernetes do sua aplica\u00e7\u00e3o no diret\u00f3rio templates/ O values.yaml cont\u00e9m os valores padr\u00e3o para um Chart. Esses valores podem ser substitu\u00eddos pelos usu\u00e1rios durante a instala\u00e7\u00e3o do helm ou atualiza\u00e7\u00e3o do helm fazendo altera\u00e7\u00f5es no arquivo ou usando a op\u00e7\u00e3o --set para sobrescrever valores (geralmente senhas e dados sens\u00edveis). O diret\u00f3rio templates/ cont\u00e9m os arquivos de modelo que ser\u00e3o processados \u200b\u200bpara gerar os manifestos finais do Kubernetes para implanta\u00e7\u00e3o. O arquivo Chart.yaml cont\u00e9m os metadados do Chart. O diret\u00f3rio charts/ pode conter subcharts Depois de empacotar sua aplica\u00e7\u00e3o como um Chart Helm, voc\u00ea pode implant\u00e1-lo em um cluster Kubernetes: Install the Helm chart using the following command 1 2 3 4 # release-name: name for the release # chart-name: name of the chart helm install <release-name> <chart-name> Personalize a instala\u00e7\u00e3o fornecendo values.yaml ou usando o sinalizador --set para substituir valores espec\u00edficos: 1 helm install <release-name> <chart-name> --values values.yaml --set database.password = $DB_PASS use --set to specify values directly on the command line. Updating and Uninstalling 1 2 3 4 5 # To update a release, run: helm upgrade <release-name> <chart-name> # To uninstall a release, run: helm uninstall <release-name> Instale ou atualize uma release com um comando Use helm upgrade com o par\u00e2metro --install . Isso far\u00e1 com que o Helm verifique se a release j\u00e1 est\u00e1 instalada para atualiza\u00e7\u00e3o. Caso contr\u00e1rio, ele executar\u00e1 uma instala\u00e7\u00e3o. 1 helm upgrade --install <release> --values <values file> <chart directory> --set <key.parameter> = <value> Values Files Um dos objetos built-in em um template helm \u00e9 o Values . Este objeto fornece acesso aos valores passados \u200b\u200bpara o Chart. Um arquivo com values \u00e9 passado para a instala\u00e7\u00e3o ou atualiza\u00e7\u00e3o do helm com o sinalizador -f helm install -f myvals.yaml ./mychart Par\u00e2metros individuais podem ser passados \u200b\u200bcom --set 1 helm install --set foo = bar ./mychart Os arquivos de valores s\u00e3o arquivos YAML simples. Vamos editar mychart/values.yaml e depois editar nosso template de ConfigMap removendo os valores padr\u00f5es em values.yaml , vamos definir apenas um par\u00e2metro: 1 favoriteDrink : coffee Now we can use this inside of a template: 1 2 3 4 5 6 7 apiVersion : v1 kind : ConfigMap metadata : name : {{ .Release.Name }} -configmap data : myvalue : \"Hello World\" drink : {{ .Values.favoriteDrink }} Notice on the last line we access favoriteDrink as an attribute of Values How this renders: 1 helm install geared-marsupi ./mychart --dry-run --debug 1 2 install.go:158 : [ debug ] Original chart version : \"\" install.go:175 : [ debug ] CHART PATH : /home/bagratte/src/playground/mychart 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 NAME : geared-marsupi LAST DEPLOYED : Wed Feb 19 23:21:13 2020 NAMESPACE : default STATUS : pending-install REVISION : 1 TEST SUITE : None USER-SUPPLIED VALUES : {} COMPUTED VALUES : favoriteDrink : coffee HOOKS : MANIFEST : --- # Source: mychart/templates/configmap.yaml apiVersion : v1 kind : ConfigMap metadata : name : geared-marsupi-configmap data : myvalue : \"Hello World\" drink : coffee Como favoriteDrink \u00e9 definido no arquivo values.yaml como coffee , esse \u00e9 o valor exibido no template. Podemos substituir isso facilmente adicionando um parametro --set em nossa chamada para a instala\u00e7\u00e3o do helm: 1 helm install solid-vulture ./mychart --dry-run --debug --set favoriteDrink = slurm 1 2 install.go:158 : [ debug ] Original chart version : \"\" install.go:175 : [ debug ] CHART PATH : /home/bagratte/src/playground/mychart 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 NAME : solid-vulture LAST DEPLOYED : Wed Feb 19 23:25:54 2020 NAMESPACE : default STATUS : pending-install REVISION : 1 TEST SUITE : None USER-SUPPLIED VALUES : favoriteDrink : slurm COMPUTED VALUES : favoriteDrink : slurm HOOKS : MANIFEST : --- # Source: mychart/templates/configmap.yaml apiVersion : v1 kind : ConfigMap metadata : name : solid-vulture-configmap data : myvalue : \"Hello World\" drink : slurm J\u00e1 que --set tem preced\u00eancia maior que o arquivo values.yaml padr\u00e3o, nosso modelo gera drink: slurm . Os arquivos de valores tamb\u00e9m podem conter conte\u00fado mais estruturado. Por exemplo: poder\u00edamos criar uma se\u00e7\u00e3o favorita em nosso arquivo values.yaml e adicionar nossas chaves l\u00e1: 1 2 3 favorite : drink : coffee food : pizza Agora ter\u00edamos que modificar um pouco o template: 1 2 3 4 5 6 7 8 apiVersion : v1 kind : ConfigMap metadata : name : {{ .Release.Name }} -configmap data : myvalue : \"Hello World\" drink : {{ .Values.favorite.drink }} food : {{ .Values.favorite.food }} Deleting a default key Se precisar excluir uma chave definida no values , voc\u00ea pode substituir o valor da chave para nulo , nesse caso o Helm ir\u00e1 remover\u00e1 a chave. Exemplo: o Chart Drupal est\u00e1vel permite configurar um liveness probe Aqui est\u00e3o os valores padr\u00e3o: 1 2 3 4 5 livenessProbe : httpGet : path : /user/login port : http initialDelaySeconds : 120 Se voc\u00ea tentar substituir o handler usado no livenessProbe para exec em vez de httpGet usando: 1 --set livenessProbe.exec.command=[cat,docroot/CHANGELOG.txt] O Helm unir\u00e1 as chaves, resultando no seguinte YAML: 1 2 3 4 5 6 7 8 9 livenessProbe : httpGet : path : /user/login port : http exec : command : - cat - docroot/CHANGELOG.txt initialDelaySeconds : 120 No entanto, deployment falharia porque voc\u00ea n\u00e3o pode declarar mais de um handler para o livenessProbe . Para superar isso, voc\u00ea pode instruir o Helm a excluir livenessProbe.httpGet definindo-o como null : 1 helm install stable/drupal --set image=my-registry/drupal:0.1.0 --set livenessProbe.httpGet=null --set livenessProbe.exec.command=[cat,docroot/CHANGELOG.txt]","title":"Helm"},{"location":"helm/#helm","text":"Helm \u00e9 um gerenciador de pacotes popular para Kubernetes que ajuda voc\u00ea a empacotar, implantar e gerenciar aplicativos.","title":"Helm"},{"location":"helm/#helm-installation","text":"1 2 3 curl -fsSL -o get_helm.sh https://raw.githubusercontent.com/helm/helm/main/scripts/get-helm-3 chmod 700 get_helm.sh ./get_helm.sh","title":" Helm Installation"},{"location":"helm/#using-helm-charts","text":"Requirements Kind Cluster Running Disponibilizando um reposit\u00f3rio de charts: 1 2 3 4 5 6 7 8 helm repo add bitnami https://charts.bitnami.com/bitnami helm repo update # List of available charts: helm search repo bitnami # Show Chart details: helm show chart bitnami/mysql Depois de instalado, voc\u00ea poder\u00e1 listar os charts que pode instalar: 1 helm search repo bitnami 1 2 3 4 5 6 NAME CHART VERSION APP VERSION DESCRIPTION bitnami/bitnami-common 0.0.9 0.0.9 DEPRECATED Chart with custom ... bitnami/airflow 8.0.2 2.0.0 Apache Airflow is a platform ... bitnami/apache 8.2.3 2.4.46 Chart for Apache HTTP Server bitnami/aspnet-core 1.2.3 3.1.9 ASP.NET Core is a framework ... # ... and many more","title":"Using Helm Charts"},{"location":"helm/#deploying-a-chart","text":"instalando um chart do reposit\u00f3rio da bitnami : 1 helm install bitnami/mysql --generate-name 1 2 3 4 5 6 7 NAME: mysql-1612624192 LAST DEPLOYED: Sat Feb 6 16:09:56 2021 NAMESPACE: default STATUS: deployed REVISION: 1 TEST SUITE: None NOTES: ... Removendo o chart instalando anteriormente: 1 helm uninstall mysql-1617481683","title":"Deploying a chart"},{"location":"helm/#helm-basic-usage","text":"Check Helm commands oficial documentation 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 # Cria um novo Chart helm create <chart-name> # Instala um pacote em um cluster Kubernetes. helm install <chart-name> ./<chart-folder> # Atualiza um pacote que j\u00e1 est\u00e1 instalado. helm upgrade <chart-name> ./<chart-folder> # Desinstala um pacote de um cluster Kubernetes. helm uninstall <chart-name> # Lista todos os pacotes instalados em um cluster Kubernetes. helm list # Mostra o status de um pacote instalado em um cluster Kubernetes. helm status <chart-name> # Mostra informa\u00e7\u00f5es detalhadas sobre um pacote do Helm. helm show chart ./<chart-folder> # Adiciona um reposit\u00f3rio de Helm charts. helm repo add stable https://charts.helm.sh/stable # Atualiza os reposit\u00f3rios do Helm. helm repo update # Pesquisa por pacotes dispon\u00edveis em reposit\u00f3rios. helm search repo # Verifica a validade de um pacote do Helm. helm lint ./<chart-folder> # Empacota um diret\u00f3rio em um arquivo .tgz. helm package ./<chart-folder> # Instala um plugin do Helm. helm plugin add https://github.com/databus23/helm-diff # Lista todos os plugins instalados. helm plugin list # Atualiza um plugin do Helm. helm plugin update diff","title":"Helm basic usage"},{"location":"helm/#empacotando-sua-aplicacao-usando-helm","text":"Para empacotar sua aplica\u00e7\u00e3o, voc\u00ea s\u00f3 precisa navegar at\u00e9 o diret\u00f3rio raiz do sua aplica\u00e7\u00e3o e criar um Chart Helm executando o comando helm create Isso criar\u00e1 uma nova estrutura de diret\u00f3rio que cont\u00e9m modelos, valores e outros arquivos de configura\u00e7\u00e3o. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 cloud-native/ \u251c\u2500\u2500 Chart.yaml \u251c\u2500\u2500 charts \u251c\u2500\u2500 templates \u2502 \u251c\u2500\u2500 NOTES.txt \u2502 \u251c\u2500\u2500 _helpers.tpl \u2502 \u251c\u2500\u2500 deployment.yaml \u2502 \u251c\u2500\u2500 hpa.yaml \u2502 \u251c\u2500\u2500 ingress.yaml \u2502 \u251c\u2500\u2500 service.yaml \u2502 \u251c\u2500\u2500 serviceaccount.yaml \u2502 \u2514\u2500\u2500 tests \u2502 \u2514\u2500\u2500 test-connection.yaml \u2514\u2500\u2500 values.yaml Agora basta modificar os arquivos gerados no diret\u00f3rio do Chart: Modifique o arquivo Chart.yaml para fornecer metadados sobre seu Chart Personalize o arquivo values.yaml para definir vari\u00e1veis \u200b\u200be valores padr\u00e3o para sua aplica\u00e7\u00e3o. Personalize os manifestos do Kubernetes do sua aplica\u00e7\u00e3o no diret\u00f3rio templates/ O values.yaml cont\u00e9m os valores padr\u00e3o para um Chart. Esses valores podem ser substitu\u00eddos pelos usu\u00e1rios durante a instala\u00e7\u00e3o do helm ou atualiza\u00e7\u00e3o do helm fazendo altera\u00e7\u00f5es no arquivo ou usando a op\u00e7\u00e3o --set para sobrescrever valores (geralmente senhas e dados sens\u00edveis). O diret\u00f3rio templates/ cont\u00e9m os arquivos de modelo que ser\u00e3o processados \u200b\u200bpara gerar os manifestos finais do Kubernetes para implanta\u00e7\u00e3o. O arquivo Chart.yaml cont\u00e9m os metadados do Chart. O diret\u00f3rio charts/ pode conter subcharts Depois de empacotar sua aplica\u00e7\u00e3o como um Chart Helm, voc\u00ea pode implant\u00e1-lo em um cluster Kubernetes:","title":"Empacotando sua aplica\u00e7\u00e3o usando Helm"},{"location":"helm/#install-the-helm-chart-using-the-following-command","text":"1 2 3 4 # release-name: name for the release # chart-name: name of the chart helm install <release-name> <chart-name> Personalize a instala\u00e7\u00e3o fornecendo values.yaml ou usando o sinalizador --set para substituir valores espec\u00edficos: 1 helm install <release-name> <chart-name> --values values.yaml --set database.password = $DB_PASS use --set to specify values directly on the command line.","title":"Install the Helm chart using the following command"},{"location":"helm/#updating-and-uninstalling","text":"1 2 3 4 5 # To update a release, run: helm upgrade <release-name> <chart-name> # To uninstall a release, run: helm uninstall <release-name> Instale ou atualize uma release com um comando Use helm upgrade com o par\u00e2metro --install . Isso far\u00e1 com que o Helm verifique se a release j\u00e1 est\u00e1 instalada para atualiza\u00e7\u00e3o. Caso contr\u00e1rio, ele executar\u00e1 uma instala\u00e7\u00e3o. 1 helm upgrade --install <release> --values <values file> <chart directory> --set <key.parameter> = <value>","title":"Updating and Uninstalling"},{"location":"helm/#values-files","text":"Um dos objetos built-in em um template helm \u00e9 o Values . Este objeto fornece acesso aos valores passados \u200b\u200bpara o Chart. Um arquivo com values \u00e9 passado para a instala\u00e7\u00e3o ou atualiza\u00e7\u00e3o do helm com o sinalizador -f helm install -f myvals.yaml ./mychart Par\u00e2metros individuais podem ser passados \u200b\u200bcom --set 1 helm install --set foo = bar ./mychart Os arquivos de valores s\u00e3o arquivos YAML simples. Vamos editar mychart/values.yaml e depois editar nosso template de ConfigMap removendo os valores padr\u00f5es em values.yaml , vamos definir apenas um par\u00e2metro: 1 favoriteDrink : coffee Now we can use this inside of a template: 1 2 3 4 5 6 7 apiVersion : v1 kind : ConfigMap metadata : name : {{ .Release.Name }} -configmap data : myvalue : \"Hello World\" drink : {{ .Values.favoriteDrink }} Notice on the last line we access favoriteDrink as an attribute of Values How this renders: 1 helm install geared-marsupi ./mychart --dry-run --debug 1 2 install.go:158 : [ debug ] Original chart version : \"\" install.go:175 : [ debug ] CHART PATH : /home/bagratte/src/playground/mychart 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 NAME : geared-marsupi LAST DEPLOYED : Wed Feb 19 23:21:13 2020 NAMESPACE : default STATUS : pending-install REVISION : 1 TEST SUITE : None USER-SUPPLIED VALUES : {} COMPUTED VALUES : favoriteDrink : coffee HOOKS : MANIFEST : --- # Source: mychart/templates/configmap.yaml apiVersion : v1 kind : ConfigMap metadata : name : geared-marsupi-configmap data : myvalue : \"Hello World\" drink : coffee Como favoriteDrink \u00e9 definido no arquivo values.yaml como coffee , esse \u00e9 o valor exibido no template. Podemos substituir isso facilmente adicionando um parametro --set em nossa chamada para a instala\u00e7\u00e3o do helm: 1 helm install solid-vulture ./mychart --dry-run --debug --set favoriteDrink = slurm 1 2 install.go:158 : [ debug ] Original chart version : \"\" install.go:175 : [ debug ] CHART PATH : /home/bagratte/src/playground/mychart 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 NAME : solid-vulture LAST DEPLOYED : Wed Feb 19 23:25:54 2020 NAMESPACE : default STATUS : pending-install REVISION : 1 TEST SUITE : None USER-SUPPLIED VALUES : favoriteDrink : slurm COMPUTED VALUES : favoriteDrink : slurm HOOKS : MANIFEST : --- # Source: mychart/templates/configmap.yaml apiVersion : v1 kind : ConfigMap metadata : name : solid-vulture-configmap data : myvalue : \"Hello World\" drink : slurm J\u00e1 que --set tem preced\u00eancia maior que o arquivo values.yaml padr\u00e3o, nosso modelo gera drink: slurm . Os arquivos de valores tamb\u00e9m podem conter conte\u00fado mais estruturado. Por exemplo: poder\u00edamos criar uma se\u00e7\u00e3o favorita em nosso arquivo values.yaml e adicionar nossas chaves l\u00e1: 1 2 3 favorite : drink : coffee food : pizza Agora ter\u00edamos que modificar um pouco o template: 1 2 3 4 5 6 7 8 apiVersion : v1 kind : ConfigMap metadata : name : {{ .Release.Name }} -configmap data : myvalue : \"Hello World\" drink : {{ .Values.favorite.drink }} food : {{ .Values.favorite.food }}","title":"Values Files"},{"location":"helm/#deleting-a-default-key","text":"Se precisar excluir uma chave definida no values , voc\u00ea pode substituir o valor da chave para nulo , nesse caso o Helm ir\u00e1 remover\u00e1 a chave. Exemplo: o Chart Drupal est\u00e1vel permite configurar um liveness probe Aqui est\u00e3o os valores padr\u00e3o: 1 2 3 4 5 livenessProbe : httpGet : path : /user/login port : http initialDelaySeconds : 120 Se voc\u00ea tentar substituir o handler usado no livenessProbe para exec em vez de httpGet usando: 1 --set livenessProbe.exec.command=[cat,docroot/CHANGELOG.txt] O Helm unir\u00e1 as chaves, resultando no seguinte YAML: 1 2 3 4 5 6 7 8 9 livenessProbe : httpGet : path : /user/login port : http exec : command : - cat - docroot/CHANGELOG.txt initialDelaySeconds : 120 No entanto, deployment falharia porque voc\u00ea n\u00e3o pode declarar mais de um handler para o livenessProbe . Para superar isso, voc\u00ea pode instruir o Helm a excluir livenessProbe.httpGet definindo-o como null : 1 helm install stable/drupal --set image=my-registry/drupal:0.1.0 --set livenessProbe.httpGet=null --set livenessProbe.exec.command=[cat,docroot/CHANGELOG.txt]","title":"Deleting a default key"},{"location":"kubernetes/","text":"Kubernetes O Kubernetes \u00e9 uma plataforma de orquestra\u00e7\u00e3o de cont\u00eaineres que oferece um conjunto de APIs que permitem a automa\u00e7\u00e3o e o gerenciamento eficiente de aplicativos em cont\u00eaineres. Kind Install Kind \u00e9 uma ferramenta que permite executar clusters Kubernetes locais usando cont\u00eaineres Docker Para praticarmos, criaremos uma pequeno cluster utilizando o Kind (Kubernetes in Docker) para usarmos de exemplo Requirements Docker Installed kubectl Installed Installer Script 1 2 3 4 5 6 # For AMD64 / x86_64 [ $( uname -m ) = x86_64 ] && curl -Lo ./kind https://kind.sigs.k8s.io/dl/v0.19.0/kind-linux-amd64 # For ARM64 [ $( uname -m ) = aarch64 ] && curl -Lo ./kind https://kind.sigs.k8s.io/dl/v0.19.0/kind-linux-arm64 chmod +x ./kind sudo mv ./kind /usr/local/bin/kind Criando um Cluster Kubernetes Crie um cluster executando o seguinte comando: 1 2 kind create cluster kubectl cluster-info Para um cluster mais personalizado, use um arquivo config.yaml com a configura\u00e7\u00e3o de cluster desejada: 1 2 3 4 5 6 kind : Cluster apiVersion : kind.x-k8s.io/v1alpha4 nodes : - role : control-plane - role : worker - role : worker 1 kind create cluster --config config.yaml Neste exemplo, definimos um cluster com um control-plane e dois workers Voc\u00ea deve conseguir ver os n\u00f3s do cluster em execu\u00e7\u00e3o com o comando: docker ps : 1 isntruct @DESKTOP : ~/ home / kind $ docker ps 1 2 3 4 CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 3 d5138d41558 kindest / node : v1 .27.1 \"/usr/local/bin/entr\u2026\" About a minute ago Up About a minute kind - worker 7 ff553f3ee0f kindest / node : v1 .27.1 \"/usr/local/bin/entr\u2026\" About a minute ago Up About a minute kind - worker2 4 ccd303f4e07 kindest / node : v1 .27.1 \"/usr/local/bin/entr\u2026\" About a minute ago Up About a minute 127.0.0.1 : 35617 -> 6443 / tcp kind - control - plane Interacting with the Cluster Depois de criar um cluster, voc\u00ea pode usar kubectl para interagir com ele usando o arquivo de configura\u00e7\u00e3o gerado por kind. Por padr\u00e3o, a configura\u00e7\u00e3o de acesso ao cluster \u00e9 armazenada em ${HOME}/.kube/config se a vari\u00e1vel de ambiente $KUBECONFIG n\u00e3o estiver definida. Kubectl Basic Usage 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 # Verificar a vers\u00e3o do cliente e do servidor Kubernetes kubectl version # Obter informa\u00e7\u00f5es sobre os componentes do cluster kubectl cluster-info # Verificar o status de sa\u00fade dos n\u00f3s do cluster kubectl get nodes # Obter informa\u00e7\u00f5es sobre um ou mais recursos kubectl get <resouce> -n <namespace> kubectl get namespaces -A # -A: get resources on all namespaces # Criar um namespace kubectl create namespace <namespace> # Trocar para um namespace espec\u00edfico kubectl config set-context --current --namespace = <namespace> # Listar os servi\u00e7os dispon\u00edveis kubectl get services # Listar os deployments dispon\u00edveis kubectl get deployments #View cluster events: kubectl get events # Exibir eventos relacionados a um recurso kubectl describe events #View the kubectl configuration: kubectl config view # Verificar a utiliza\u00e7\u00e3o de recursos (CPU, mem\u00f3ria) por um Pod kubectl top pod my-pod # Obter informa\u00e7\u00f5es sobre um pod em formato YAML/JSON kubectl get pod <pod> -o yaml/json # Criar um novo recurso kubectl create <resource> <-optins> kubectl create deployment my-deployment --image = my-image:tag --replicas = 2 # Redimensionar o n\u00famero de r\u00e9plicas de um conjunto de r\u00e9plicas (Deployment) kubectl scale deployment/<deployment-name> --replicas = 3 # Apagar um ou mais recursos kubectl delete <resouce> <resource-name> kubectl delete pod my-pod # Exibir detalhes de um recurso espec\u00edfico kubectl describe <resource> -n <namespace> kubectl describe pod my-pod -n <namespace> # Executar um comando em um cont\u00eainer de um Pod kubectl exec <pod-name> -n <namespace> -- <command> kubectl exec my-pod -n <namespace> -- ls /app # Executar um comando espec\u00edfico em todos os Pods de um conjunto de r\u00e9plicas kubectl exec deployment/<deployment-name> -- ls /app # Criar um Pod tempor\u00e1rio para executar um comando de depura\u00e7\u00e3o kubectl debug my-pod --image = debug-image:latest # Acompanhar os logs de um Pod kubectl logs <pod-name> # Acessar a linha de comando de um cont\u00eainer em execu\u00e7\u00e3o em um Pod kubectl attach <pod-name> -c <container-name> kubectl attach my-pod -c <container-name> # Expor um servi\u00e7o para acesso externo kubectl expose deployment <deployment-name> --port = <port> kubectl expose deployment my-deployment --port = 8080 # Criar um encaminhamento de porta para acessar um Pod kubectl port-forward <pod-name> <container-port>:<host-port> kubectl port-forward my-pod 8080 :80 # Criar um secret a partir de um arquivo ou valor kubectl create secret <type> <secret-name> --from-file = <secret-file>.txt kubectl create secret generic my-secret --from-file = my-secret-file.txt # Criar um ingress para rotear o tr\u00e1fego externo para um servi\u00e7o kubectl create ingress my-ingress --rule = host = my-domain.com # Criar um Job para executar uma tarefa em lote kubectl create job my-job --image = my-image:tag # Criar um cronjob para executar tarefas em intervalos regulares kubectl create cronjob my-cronjob --schedule = \"0 0 * * *\" # Criar um PersistentVolume e PersistentVolumeClaim kubectl create persistentvolume my-pv --size = 1Gi # Criar um ConfigMap a partir de um arquivo de configura\u00e7\u00e3o kubectl create configmap my-configmap --from-file = my-config.txt # Atualizar a configura\u00e7\u00e3o de um recurso kubectl edit deployment/<deployment-name> # Atualizar a imagem de um Pod em execu\u00e7\u00e3o kubectl set image pod/my-pod my-container = my-image:tag # Visualizar o estado de um rollout (deployment, replicaset, etc.) kubectl rollout status deployment/<deployment-name> Note: Para mais informa\u00e7\u00f5es sobre o utilit\u00e1rio kubectl , veja: kubectl overview . Deploying a kubernetes Dashboard UI O kubernetes n\u00e3o possui uma interface grafica, mas podemos instalar uma com os seguintes comandos: 1 2 3 4 kubectl apply -f https://raw.githubusercontent.com/kubernetes/dashboard/v2.7.0/aio/deploy/recommended.yaml # Via helm : helm install dashboard kubernetes-dashboard/kubernetes-dashboard -n kubernetes-dashboard --create-namespace Tenha acesso a Dashboard do Kubernetes executando: 1 2 3 export POD_NAME = $( kubectl get pods -n kubernetes-dashboard -l \"app.kubernetes.io/name=kubernetes-dashboard,app.kubernetes.io/instance=dashboard\" -o jsonpath = \"{.items[0].metadata.name}\" ) echo https://127.0.0.1:8443/ kubectl -n kubernetes-dashboard port-forward $POD_NAME 8443 :8443 Agora voc\u00ea apenas precisa acessar: https://localhost:8443 A dashboard tambem pode ser acessada via proxy : Isso far\u00e1 o proxy dos endpoints do cluster do Kubernetes para o host, para que possamos acess\u00e1-los 1 kubectl proxy E ent\u00e3o sua dashboard estar\u00e1 disponivel neste endere\u00e7o: http://localhost:8001/api/v1/namespaces/kubernetes-dashboard/services/https:dashboard-kubernetes-dashboard:https/proxy/#/login Accessing the Dashboard UI Precisamos criar um usu\u00e1rio e anexar a permiss\u00e3o necess\u00e1ria para acessar a dashboard Criando um usu\u00e1rio Conceder privil\u00e9gios de administrador \u00e0 service-account da Dashboard pode ser um risco de seguran\u00e7a Criando uma Service Accout service-account.yaml Isso criar\u00e1 uma service-account com o nome admin-user no namespace kubernetes-dashboard : 1 2 3 4 5 apiVersion : v1 kind : ServiceAccount metadata : name : admin-user namespace : kubernetes-dashboard Criando uma ClusterRoleBinding cluster-role-binding.yaml 1 2 3 4 5 6 7 8 9 10 11 12 apiVersion : rbac.authorization.k8s.io/v1 kind : ClusterRoleBinding metadata : name : admin-user roleRef : apiGroup : rbac.authorization.k8s.io kind : ClusterRole name : cluster-admin subjects : - kind : ServiceAccount name : admin-user namespace : kubernetes-dashboard Execute um Apply nos manifestos 1 kubectl apply -f service-account.yaml -f cluster-role-binding.yaml Crie um Bearer Token Para obter o token que podemos usar para fazer login, execute o seguinte comando: 1 kubectl -n kubernetes-dashboard create token admin-user Configura\u00e7\u00e3o de Pod e Deployments pods Use o comando kubectl create para criar um pod. O pod executa um cont\u00eainer com base na imagem fornecida. Via kubectl: 1 kubectl run my-pod --image = my-image:tag --port = 8080 Usando um arquivo YAML: Crie um arquivo YAML chamado pod.yaml com o seguinte conte\u00fado: pod.yaml 1 2 3 4 5 6 7 8 9 10 apiVersion : v1 kind : Pod metadata : name : my-pod spec : containers : - name : my-container image : my-image:tag ports : - containerPort : 8080 Em seguida, aplique o arquivo YAML usando o seguinte comando: 1 kubectl apply -f pod.yaml Veja the Pod: 1 kubectl get pods <pod-name> -n <namespace> A sa\u00edda do comando deve ser similar: 1 2 3 4 NAME READY STATUS RESTARTS AGE my-pod-h5qcc 1/1 Running 0 24m cloud-native-9rbfn 1/1 Running 0 24m ... Deployment Use o comando kubectl create para criar um Deployment que gerencia um pod . O pod executa um cont\u00eainer com base na imagem fornecida. 1 2 # Run a test container image that includes a webserver kubectl create deployment hello-node --image = registry.k8s.io/e2e-test-images/agnhost:2.39 -- /agnhost netexec --http-port = 8080 Para realizar o deployment via yaml: deployment.yaml 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 apiVersion : apps/v1 kind : Deployment metadata : name : nginx-deployment labels : app : nginx spec : replicas : 3 selector : matchLabels : app : nginx template : metadata : labels : app : nginx spec : containers : - name : nginx image : nginx:1.14.2 ports : - containerPort : 80 apply that deployment manifest on cluster running: 1 kubectl apply -f deployment.yaml Isso criar\u00e1 um Deployment e um ReplicaSet no namespace default , para subir 3 pods de nginx Veja o Deployment: 1 kubectl get deployments hello-node -n <namespace> A saida do comando deve ser similar: 1 2 NAME READY UP-TO-DATE AVAILABLE AGE hello-node 3/3 3 3 1m Cria\u00e7\u00e3o de ConfigMaps e Secrets Crie e configure um ConfigMap e Secrets usando kubectl e YAML ConfigMap via Kubectl: 1 kubectl create configmap <configmap-name> --from-literal = key1 = value1 --from-literal = key2 = value2 via yaml: Crie um arquivo yaml chamado configmap.yaml com o seguinte conte\u00fado: configmap.yaml 1 2 3 4 5 6 7 apiVersion : v1 kind : ConfigMap metadata : name : <configmap-name> data : key1 : value1 key2 : value2 Then apply the YAML manifest: 1 kubectl apply -f configmap.yaml Veja os ConfigMaps: 1 kubectl get configmap <configmap-name> -n <namespace> A saida do comando deve ser similar: 1 2 NAME DATA AGE <configmap-name> 0 3h15m Secrets Via Kubectl: 1 kubectl create secret generic <secret-name> --from-literal = key1 = value1 --from-literal = key2 = value2 Via YAML: Crie um arquivo yaml chamado secrets.yaml com o seguinte conte\u00fado: secrets.yaml 1 2 3 4 5 6 7 8 apiVersion : v1 kind : Secret metadata : name : <secret-name> type : Opaque data : key1 : dmFsdWUx # Base64 encoded value1 key2 : dmFsdWUy # Base64 encoded value2 Certifique-se de codificar os valores no formato Base64 antes de adicion\u00e1-los ao arquivo YAML. 1 kubectl apply -f secret.yaml Veja as secrets: 1 kubectl get secret -A A saida deve ser semelhante: 1 2 3 4 5 6 7 NAME TYPE DATA AGE <secret-name> Opaque 2 2h12m dashboard-kubernetes-dashboard-certs Opaque 0 3h16m kubernetes-dashboard-csrf Opaque 1 3h16m kubernetes-dashboard-key-holder Opaque 2 3h16m sh.helm.release.v1.dashboard.v1 helm.sh/release.v1 1 3h16m ... Configura\u00e7\u00e3o de Services e Ingress Crie e configure um service e um ingress usando kubectl e YAML: Services Tipos disponiveis Os tipos de servi\u00e7o do Kubernetes permitem que voc\u00ea especifique o tipo de servi\u00e7o que deseja. ClusterIP Exp\u00f5e o servi\u00e7o em um IP interno do cluster; Esse tipo torna o servi\u00e7o acess\u00edvel apenas de dentro do cluster; Esse \u00e9 o tipo padr\u00e3o de service utilizado se nenhum valor for definido; NodePort Exp\u00f5e o servi\u00e7o no IP de cada n\u00f3 em uma porta est\u00e1tica (o NodePort). LoadBalancer Exp\u00f5e o servi\u00e7o externamente usando um load-balancer externo; ExternalName Permite expor um servi\u00e7o externo atrav\u00e9s de um DNS personalizado; Via kubectl: 1 kubectl expose deployment <deployment> -n <namespace> --type = <service-type> --port = 80 --target-port = 8080 Via YAML: Crie um arquivo YAML chamado com o seguinte conte\u00fado: service.yaml 1 2 3 4 5 6 7 8 9 10 11 apiVersion : v1 kind : Service metadata : name : <service-name> spec : selector : <selector-label> : <selector-value> ports : - protocol : <protocol> port : <port> targetPort : <target-port> Then apply the YAML manifest: 1 kubectl apply -f service.yaml Veja os Services: 1 kubectl get service <service-name> A saida deve ser semelhante: 1 2 NAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGE <service-name> ClusterIP 10.96.143.1 <none> 443/TCP 3h18m Ingress Via kubectl: 1 kubectl create ingress <ingress-name> --rule = <rule-pattern> Via YAML: Crie um arquivo YAML chamado ingress.yaml com o seguinte conte\u00fado: ingress.yaml 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 apiVersion : networking.k8s.io/v1 kind : Ingress metadata : name : <ingress-name> spec : rules : - host : <host-pattern> http : paths : - pathType : Prefix path : / backend : service : name : <backend-service> port : number : <backend-service-port> Then apply the YAML manifest: 1 kubectl apply -f ingress.yaml Vej\u00e1 o Ingress: 1 kubectl get ingress A saida deve ser semelhante: 1 2 NAME CLASS HOSTS ADDRESS PORTS AGE cloud-native <none> instruct.cloud-native.com.br 80 7s Configura\u00e7\u00e3o de um Volume Via kubectl: 1 kubectl create -f <volume-manifest.yaml> Via YAML: Crie um arquivo YAML chamado volume-manifest.yaml com o seguinte conte\u00fado: volume.yaml 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 apiVersion : v1 kind : PersistentVolume metadata : name : <volume-name> spec : capacity : storage : <storage-size> accessModes : - <access-mode> hostPath : path : <host-path> --- apiVersion : v1 kind : PersistentVolumeClaim metadata : name : <pvc-name> spec : accessModes : - <access-mode> resources : requests : storage : <storage-size> volumeName : <volume-name> Then apply the YAML manifest: 1 kubectl apply -f volume.yaml Veja os Persistence Volume Clain : 1 kubectl get pvc A saida deve ser semelhante: 1 2 3 NAME CAPACITY ACCESS MODES RECLAIM POLICY STATUS CLAIM STORAGECLASS REASON AGE pvc-043ed9c1-... 8Gi RWO Delete Bound default/data-grafana-loki-1686599256-querier-0 standard 15m pvc-188f0d07-... 8Gi RWO Delete Bound default/grafana-loki-1686599438-compactor standard 12m Veja os Persistence Volume : 1 kubectl get pv A saida deve ser semelhante: 1 2 3 4 luke@DESKTOP-7A3AHF1:~/luke/kind$ kubectl get pvc NAME STATUS VOLUME CAPACITY ACCESS MODES STORAGECLASS AGE data-689256-0 Bound pvc-6a2c5557-21b3-46a1-abee-b79c79bcabd8 8Gi RWO standard 15m data-18656-0 Bound pvc-043ed9c1-8441-4e1c-9fbb-49c4f58b3140 8Gi RWO standard 15m Destruindo um Cluster Se voc\u00ea criou um cluster com kind create cluster, a exclus\u00e3o \u00e9 igualmente simples: 1 kind delete cluster","title":"Kubernetes"},{"location":"kubernetes/#kubernetes","text":"O Kubernetes \u00e9 uma plataforma de orquestra\u00e7\u00e3o de cont\u00eaineres que oferece um conjunto de APIs que permitem a automa\u00e7\u00e3o e o gerenciamento eficiente de aplicativos em cont\u00eaineres.","title":"Kubernetes"},{"location":"kubernetes/#kind-install","text":"Kind \u00e9 uma ferramenta que permite executar clusters Kubernetes locais usando cont\u00eaineres Docker Para praticarmos, criaremos uma pequeno cluster utilizando o Kind (Kubernetes in Docker) para usarmos de exemplo Requirements Docker Installed kubectl Installed Installer Script 1 2 3 4 5 6 # For AMD64 / x86_64 [ $( uname -m ) = x86_64 ] && curl -Lo ./kind https://kind.sigs.k8s.io/dl/v0.19.0/kind-linux-amd64 # For ARM64 [ $( uname -m ) = aarch64 ] && curl -Lo ./kind https://kind.sigs.k8s.io/dl/v0.19.0/kind-linux-arm64 chmod +x ./kind sudo mv ./kind /usr/local/bin/kind","title":" Kind Install"},{"location":"kubernetes/#criando-um-cluster-kubernetes","text":"Crie um cluster executando o seguinte comando: 1 2 kind create cluster kubectl cluster-info Para um cluster mais personalizado, use um arquivo config.yaml com a configura\u00e7\u00e3o de cluster desejada: 1 2 3 4 5 6 kind : Cluster apiVersion : kind.x-k8s.io/v1alpha4 nodes : - role : control-plane - role : worker - role : worker 1 kind create cluster --config config.yaml Neste exemplo, definimos um cluster com um control-plane e dois workers Voc\u00ea deve conseguir ver os n\u00f3s do cluster em execu\u00e7\u00e3o com o comando: docker ps : 1 isntruct @DESKTOP : ~/ home / kind $ docker ps 1 2 3 4 CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 3 d5138d41558 kindest / node : v1 .27.1 \"/usr/local/bin/entr\u2026\" About a minute ago Up About a minute kind - worker 7 ff553f3ee0f kindest / node : v1 .27.1 \"/usr/local/bin/entr\u2026\" About a minute ago Up About a minute kind - worker2 4 ccd303f4e07 kindest / node : v1 .27.1 \"/usr/local/bin/entr\u2026\" About a minute ago Up About a minute 127.0.0.1 : 35617 -> 6443 / tcp kind - control - plane","title":"Criando um Cluster Kubernetes"},{"location":"kubernetes/#interacting-with-the-cluster","text":"Depois de criar um cluster, voc\u00ea pode usar kubectl para interagir com ele usando o arquivo de configura\u00e7\u00e3o gerado por kind. Por padr\u00e3o, a configura\u00e7\u00e3o de acesso ao cluster \u00e9 armazenada em ${HOME}/.kube/config se a vari\u00e1vel de ambiente $KUBECONFIG n\u00e3o estiver definida.","title":"Interacting with the Cluster"},{"location":"kubernetes/#kubectl-basic-usage","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 # Verificar a vers\u00e3o do cliente e do servidor Kubernetes kubectl version # Obter informa\u00e7\u00f5es sobre os componentes do cluster kubectl cluster-info # Verificar o status de sa\u00fade dos n\u00f3s do cluster kubectl get nodes # Obter informa\u00e7\u00f5es sobre um ou mais recursos kubectl get <resouce> -n <namespace> kubectl get namespaces -A # -A: get resources on all namespaces # Criar um namespace kubectl create namespace <namespace> # Trocar para um namespace espec\u00edfico kubectl config set-context --current --namespace = <namespace> # Listar os servi\u00e7os dispon\u00edveis kubectl get services # Listar os deployments dispon\u00edveis kubectl get deployments #View cluster events: kubectl get events # Exibir eventos relacionados a um recurso kubectl describe events #View the kubectl configuration: kubectl config view # Verificar a utiliza\u00e7\u00e3o de recursos (CPU, mem\u00f3ria) por um Pod kubectl top pod my-pod # Obter informa\u00e7\u00f5es sobre um pod em formato YAML/JSON kubectl get pod <pod> -o yaml/json # Criar um novo recurso kubectl create <resource> <-optins> kubectl create deployment my-deployment --image = my-image:tag --replicas = 2 # Redimensionar o n\u00famero de r\u00e9plicas de um conjunto de r\u00e9plicas (Deployment) kubectl scale deployment/<deployment-name> --replicas = 3 # Apagar um ou mais recursos kubectl delete <resouce> <resource-name> kubectl delete pod my-pod # Exibir detalhes de um recurso espec\u00edfico kubectl describe <resource> -n <namespace> kubectl describe pod my-pod -n <namespace> # Executar um comando em um cont\u00eainer de um Pod kubectl exec <pod-name> -n <namespace> -- <command> kubectl exec my-pod -n <namespace> -- ls /app # Executar um comando espec\u00edfico em todos os Pods de um conjunto de r\u00e9plicas kubectl exec deployment/<deployment-name> -- ls /app # Criar um Pod tempor\u00e1rio para executar um comando de depura\u00e7\u00e3o kubectl debug my-pod --image = debug-image:latest # Acompanhar os logs de um Pod kubectl logs <pod-name> # Acessar a linha de comando de um cont\u00eainer em execu\u00e7\u00e3o em um Pod kubectl attach <pod-name> -c <container-name> kubectl attach my-pod -c <container-name> # Expor um servi\u00e7o para acesso externo kubectl expose deployment <deployment-name> --port = <port> kubectl expose deployment my-deployment --port = 8080 # Criar um encaminhamento de porta para acessar um Pod kubectl port-forward <pod-name> <container-port>:<host-port> kubectl port-forward my-pod 8080 :80 # Criar um secret a partir de um arquivo ou valor kubectl create secret <type> <secret-name> --from-file = <secret-file>.txt kubectl create secret generic my-secret --from-file = my-secret-file.txt # Criar um ingress para rotear o tr\u00e1fego externo para um servi\u00e7o kubectl create ingress my-ingress --rule = host = my-domain.com # Criar um Job para executar uma tarefa em lote kubectl create job my-job --image = my-image:tag # Criar um cronjob para executar tarefas em intervalos regulares kubectl create cronjob my-cronjob --schedule = \"0 0 * * *\" # Criar um PersistentVolume e PersistentVolumeClaim kubectl create persistentvolume my-pv --size = 1Gi # Criar um ConfigMap a partir de um arquivo de configura\u00e7\u00e3o kubectl create configmap my-configmap --from-file = my-config.txt # Atualizar a configura\u00e7\u00e3o de um recurso kubectl edit deployment/<deployment-name> # Atualizar a imagem de um Pod em execu\u00e7\u00e3o kubectl set image pod/my-pod my-container = my-image:tag # Visualizar o estado de um rollout (deployment, replicaset, etc.) kubectl rollout status deployment/<deployment-name> Note: Para mais informa\u00e7\u00f5es sobre o utilit\u00e1rio kubectl , veja: kubectl overview .","title":"Kubectl Basic Usage"},{"location":"kubernetes/#deploying-a-kubernetes-dashboard-ui","text":"O kubernetes n\u00e3o possui uma interface grafica, mas podemos instalar uma com os seguintes comandos: 1 2 3 4 kubectl apply -f https://raw.githubusercontent.com/kubernetes/dashboard/v2.7.0/aio/deploy/recommended.yaml # Via helm : helm install dashboard kubernetes-dashboard/kubernetes-dashboard -n kubernetes-dashboard --create-namespace Tenha acesso a Dashboard do Kubernetes executando: 1 2 3 export POD_NAME = $( kubectl get pods -n kubernetes-dashboard -l \"app.kubernetes.io/name=kubernetes-dashboard,app.kubernetes.io/instance=dashboard\" -o jsonpath = \"{.items[0].metadata.name}\" ) echo https://127.0.0.1:8443/ kubectl -n kubernetes-dashboard port-forward $POD_NAME 8443 :8443 Agora voc\u00ea apenas precisa acessar: https://localhost:8443 A dashboard tambem pode ser acessada via proxy : Isso far\u00e1 o proxy dos endpoints do cluster do Kubernetes para o host, para que possamos acess\u00e1-los 1 kubectl proxy E ent\u00e3o sua dashboard estar\u00e1 disponivel neste endere\u00e7o: http://localhost:8001/api/v1/namespaces/kubernetes-dashboard/services/https:dashboard-kubernetes-dashboard:https/proxy/#/login","title":"Deploying a kubernetes Dashboard UI"},{"location":"kubernetes/#accessing-the-dashboard-ui","text":"Precisamos criar um usu\u00e1rio e anexar a permiss\u00e3o necess\u00e1ria para acessar a dashboard Criando um usu\u00e1rio Conceder privil\u00e9gios de administrador \u00e0 service-account da Dashboard pode ser um risco de seguran\u00e7a Criando uma Service Accout service-account.yaml Isso criar\u00e1 uma service-account com o nome admin-user no namespace kubernetes-dashboard : 1 2 3 4 5 apiVersion : v1 kind : ServiceAccount metadata : name : admin-user namespace : kubernetes-dashboard Criando uma ClusterRoleBinding cluster-role-binding.yaml 1 2 3 4 5 6 7 8 9 10 11 12 apiVersion : rbac.authorization.k8s.io/v1 kind : ClusterRoleBinding metadata : name : admin-user roleRef : apiGroup : rbac.authorization.k8s.io kind : ClusterRole name : cluster-admin subjects : - kind : ServiceAccount name : admin-user namespace : kubernetes-dashboard Execute um Apply nos manifestos 1 kubectl apply -f service-account.yaml -f cluster-role-binding.yaml Crie um Bearer Token Para obter o token que podemos usar para fazer login, execute o seguinte comando: 1 kubectl -n kubernetes-dashboard create token admin-user","title":"Accessing the Dashboard UI"},{"location":"kubernetes/#configuracao-de-pod-e-deployments","text":"pods Use o comando kubectl create para criar um pod. O pod executa um cont\u00eainer com base na imagem fornecida. Via kubectl: 1 kubectl run my-pod --image = my-image:tag --port = 8080 Usando um arquivo YAML: Crie um arquivo YAML chamado pod.yaml com o seguinte conte\u00fado: pod.yaml 1 2 3 4 5 6 7 8 9 10 apiVersion : v1 kind : Pod metadata : name : my-pod spec : containers : - name : my-container image : my-image:tag ports : - containerPort : 8080 Em seguida, aplique o arquivo YAML usando o seguinte comando: 1 kubectl apply -f pod.yaml Veja the Pod: 1 kubectl get pods <pod-name> -n <namespace> A sa\u00edda do comando deve ser similar: 1 2 3 4 NAME READY STATUS RESTARTS AGE my-pod-h5qcc 1/1 Running 0 24m cloud-native-9rbfn 1/1 Running 0 24m ... Deployment Use o comando kubectl create para criar um Deployment que gerencia um pod . O pod executa um cont\u00eainer com base na imagem fornecida. 1 2 # Run a test container image that includes a webserver kubectl create deployment hello-node --image = registry.k8s.io/e2e-test-images/agnhost:2.39 -- /agnhost netexec --http-port = 8080 Para realizar o deployment via yaml: deployment.yaml 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 apiVersion : apps/v1 kind : Deployment metadata : name : nginx-deployment labels : app : nginx spec : replicas : 3 selector : matchLabels : app : nginx template : metadata : labels : app : nginx spec : containers : - name : nginx image : nginx:1.14.2 ports : - containerPort : 80 apply that deployment manifest on cluster running: 1 kubectl apply -f deployment.yaml Isso criar\u00e1 um Deployment e um ReplicaSet no namespace default , para subir 3 pods de nginx Veja o Deployment: 1 kubectl get deployments hello-node -n <namespace> A saida do comando deve ser similar: 1 2 NAME READY UP-TO-DATE AVAILABLE AGE hello-node 3/3 3 3 1m","title":"Configura\u00e7\u00e3o de Pod e Deployments"},{"location":"kubernetes/#criacao-de-configmaps-e-secrets","text":"Crie e configure um ConfigMap e Secrets usando kubectl e YAML ConfigMap via Kubectl: 1 kubectl create configmap <configmap-name> --from-literal = key1 = value1 --from-literal = key2 = value2 via yaml: Crie um arquivo yaml chamado configmap.yaml com o seguinte conte\u00fado: configmap.yaml 1 2 3 4 5 6 7 apiVersion : v1 kind : ConfigMap metadata : name : <configmap-name> data : key1 : value1 key2 : value2 Then apply the YAML manifest: 1 kubectl apply -f configmap.yaml Veja os ConfigMaps: 1 kubectl get configmap <configmap-name> -n <namespace> A saida do comando deve ser similar: 1 2 NAME DATA AGE <configmap-name> 0 3h15m Secrets Via Kubectl: 1 kubectl create secret generic <secret-name> --from-literal = key1 = value1 --from-literal = key2 = value2 Via YAML: Crie um arquivo yaml chamado secrets.yaml com o seguinte conte\u00fado: secrets.yaml 1 2 3 4 5 6 7 8 apiVersion : v1 kind : Secret metadata : name : <secret-name> type : Opaque data : key1 : dmFsdWUx # Base64 encoded value1 key2 : dmFsdWUy # Base64 encoded value2 Certifique-se de codificar os valores no formato Base64 antes de adicion\u00e1-los ao arquivo YAML. 1 kubectl apply -f secret.yaml Veja as secrets: 1 kubectl get secret -A A saida deve ser semelhante: 1 2 3 4 5 6 7 NAME TYPE DATA AGE <secret-name> Opaque 2 2h12m dashboard-kubernetes-dashboard-certs Opaque 0 3h16m kubernetes-dashboard-csrf Opaque 1 3h16m kubernetes-dashboard-key-holder Opaque 2 3h16m sh.helm.release.v1.dashboard.v1 helm.sh/release.v1 1 3h16m ...","title":"Cria\u00e7\u00e3o de ConfigMaps e Secrets"},{"location":"kubernetes/#configuracao-de-services-e-ingress","text":"Crie e configure um service e um ingress usando kubectl e YAML: Services Tipos disponiveis Os tipos de servi\u00e7o do Kubernetes permitem que voc\u00ea especifique o tipo de servi\u00e7o que deseja. ClusterIP Exp\u00f5e o servi\u00e7o em um IP interno do cluster; Esse tipo torna o servi\u00e7o acess\u00edvel apenas de dentro do cluster; Esse \u00e9 o tipo padr\u00e3o de service utilizado se nenhum valor for definido; NodePort Exp\u00f5e o servi\u00e7o no IP de cada n\u00f3 em uma porta est\u00e1tica (o NodePort). LoadBalancer Exp\u00f5e o servi\u00e7o externamente usando um load-balancer externo; ExternalName Permite expor um servi\u00e7o externo atrav\u00e9s de um DNS personalizado; Via kubectl: 1 kubectl expose deployment <deployment> -n <namespace> --type = <service-type> --port = 80 --target-port = 8080 Via YAML: Crie um arquivo YAML chamado com o seguinte conte\u00fado: service.yaml 1 2 3 4 5 6 7 8 9 10 11 apiVersion : v1 kind : Service metadata : name : <service-name> spec : selector : <selector-label> : <selector-value> ports : - protocol : <protocol> port : <port> targetPort : <target-port> Then apply the YAML manifest: 1 kubectl apply -f service.yaml Veja os Services: 1 kubectl get service <service-name> A saida deve ser semelhante: 1 2 NAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGE <service-name> ClusterIP 10.96.143.1 <none> 443/TCP 3h18m Ingress Via kubectl: 1 kubectl create ingress <ingress-name> --rule = <rule-pattern> Via YAML: Crie um arquivo YAML chamado ingress.yaml com o seguinte conte\u00fado: ingress.yaml 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 apiVersion : networking.k8s.io/v1 kind : Ingress metadata : name : <ingress-name> spec : rules : - host : <host-pattern> http : paths : - pathType : Prefix path : / backend : service : name : <backend-service> port : number : <backend-service-port> Then apply the YAML manifest: 1 kubectl apply -f ingress.yaml Vej\u00e1 o Ingress: 1 kubectl get ingress A saida deve ser semelhante: 1 2 NAME CLASS HOSTS ADDRESS PORTS AGE cloud-native <none> instruct.cloud-native.com.br 80 7s","title":"Configura\u00e7\u00e3o de Services e Ingress"},{"location":"kubernetes/#configuracao-de-um-volume","text":"Via kubectl: 1 kubectl create -f <volume-manifest.yaml> Via YAML: Crie um arquivo YAML chamado volume-manifest.yaml com o seguinte conte\u00fado: volume.yaml 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 apiVersion : v1 kind : PersistentVolume metadata : name : <volume-name> spec : capacity : storage : <storage-size> accessModes : - <access-mode> hostPath : path : <host-path> --- apiVersion : v1 kind : PersistentVolumeClaim metadata : name : <pvc-name> spec : accessModes : - <access-mode> resources : requests : storage : <storage-size> volumeName : <volume-name> Then apply the YAML manifest: 1 kubectl apply -f volume.yaml Veja os Persistence Volume Clain : 1 kubectl get pvc A saida deve ser semelhante: 1 2 3 NAME CAPACITY ACCESS MODES RECLAIM POLICY STATUS CLAIM STORAGECLASS REASON AGE pvc-043ed9c1-... 8Gi RWO Delete Bound default/data-grafana-loki-1686599256-querier-0 standard 15m pvc-188f0d07-... 8Gi RWO Delete Bound default/grafana-loki-1686599438-compactor standard 12m Veja os Persistence Volume : 1 kubectl get pv A saida deve ser semelhante: 1 2 3 4 luke@DESKTOP-7A3AHF1:~/luke/kind$ kubectl get pvc NAME STATUS VOLUME CAPACITY ACCESS MODES STORAGECLASS AGE data-689256-0 Bound pvc-6a2c5557-21b3-46a1-abee-b79c79bcabd8 8Gi RWO standard 15m data-18656-0 Bound pvc-043ed9c1-8441-4e1c-9fbb-49c4f58b3140 8Gi RWO standard 15m","title":"Configura\u00e7\u00e3o de um Volume"},{"location":"kubernetes/#destruindo-um-cluster","text":"Se voc\u00ea criou um cluster com kind create cluster, a exclus\u00e3o \u00e9 igualmente simples: 1 kind delete cluster","title":"Destruindo um Cluster"},{"location":"resolution/","text":"Desafio Objetivo Implantar uma aplica\u00e7\u00e3o web em um cluster Kubernetes (KIND) usando o Docker e o Helm. Passos 1. Subir um banco de dados PostgreSQL O banco deve possuir um volume para persist\u00eancia dos dados. 1 docker run --name postgres -e POSTGRES_PASSWORD = postgres -v ~/pgdata:/var/lib/postgresql/data -p 5432 :5432 -d postgres 2. Conectar uma aplica\u00e7\u00e3o ao banco de dados Apos subir o banco Postgres, tente conectar o projeto django que est\u00e1 no diret\u00f3rio desafio deste projeto. 3. Containerize a aplica\u00e7\u00e3o Containerize sua aplica\u00e7\u00e3o Django criando um Dockerfile . 4. Crie um docker-compose Crie um docker-compose com o service da aplica\u00e7\u00e3o e do banco de dados; Certifique-se de adicionar a depend\u00eancia do banco no service da aplica\u00e7\u00e3o; Confirme que sua aplica\u00e7\u00e3o consegue acessar o banco de dados; Remova as vari\u00e1veis de ambiente sens\u00edveis do c\u00f3digo. 5. Crie um cluster Kubernetes Configure um cluster Kubernetes local usando Kind com no m\u00ednimo 3 nodes; Certifique-se de que o cluster esteja pronto para receber implanta\u00e7\u00f5es. 6. Realize a instala\u00e7\u00e3o do Kubernetes Dashboard no seu cluster Voc\u00ea tamb\u00e9m precisar\u00e1 criar uma service-account e um cluster-role-binding ; Crie um token de acesso para a dashboard. 7. Empacote sua aplica\u00e7\u00e3o utilizando Helm Crie um Chart Helm para o deploy da sua aplica\u00e7\u00e3o, e configure os valores padr\u00e3o no arquivo values.yaml ; Lembre de manter o pod do banco de dados separado do pod da aplica\u00e7\u00e3o; utilize o par\u00e2metro --set ao instalar o chart helm para sobrescrever vari\u00e1veis sens\u00edveis do arquivo values.yaml ; Persista suas vari\u00e1veis atrav\u00e9s de secrets e configMaps ; Crie services para sua aplica\u00e7\u00e3o e banco; Crie um namespace para a sua aplica\u00e7\u00e3o 8. Teste sua aplica\u00e7\u00e3o usando Helm Fa\u00e7a uma pequena altera\u00e7\u00e3o na sua aplica\u00e7\u00e3o e fa\u00e7a update na implanta\u00e7\u00e3o usando o Helm Fa\u00e7a alguns testes utilizando a estrat\u00e9gia de deployment Recreate e RollingUpdate 9. Teste a escalabilidade Adicione escalabilidade horizontal criando novas replicas e um (HPA) para sua implanta\u00e7\u00e3o Adicione escalabilidade vertical definindo valores de request e limite para os resources da sua implanta\u00e7\u00e3o (HPA) - Horizontal Pod autoscaler 10. Execute um Registry localmente Crie um registry local utilizando Harbor ou Distribution Suba suas imagens para este registry e utilize-as no helm","title":"Desafio"},{"location":"resolution/#desafio","text":"","title":"Desafio"},{"location":"resolution/#objetivo","text":"Implantar uma aplica\u00e7\u00e3o web em um cluster Kubernetes (KIND) usando o Docker e o Helm.","title":"Objetivo"},{"location":"resolution/#passos","text":"","title":"Passos"},{"location":"resolution/#1-subir-um-banco-de-dados-postgresql","text":"O banco deve possuir um volume para persist\u00eancia dos dados. 1 docker run --name postgres -e POSTGRES_PASSWORD = postgres -v ~/pgdata:/var/lib/postgresql/data -p 5432 :5432 -d postgres","title":"1. Subir um banco de dados PostgreSQL"},{"location":"resolution/#2-conectar-uma-aplicacao-ao-banco-de-dados","text":"Apos subir o banco Postgres, tente conectar o projeto django que est\u00e1 no diret\u00f3rio desafio deste projeto.","title":"2. Conectar uma aplica\u00e7\u00e3o ao banco de dados"},{"location":"resolution/#3-containerize-a-aplicacao","text":"Containerize sua aplica\u00e7\u00e3o Django criando um Dockerfile .","title":"3. Containerize a aplica\u00e7\u00e3o"},{"location":"resolution/#4-crie-um-docker-compose","text":"Crie um docker-compose com o service da aplica\u00e7\u00e3o e do banco de dados; Certifique-se de adicionar a depend\u00eancia do banco no service da aplica\u00e7\u00e3o; Confirme que sua aplica\u00e7\u00e3o consegue acessar o banco de dados; Remova as vari\u00e1veis de ambiente sens\u00edveis do c\u00f3digo.","title":"4. Crie um docker-compose"},{"location":"resolution/#5-crie-um-cluster-kubernetes","text":"Configure um cluster Kubernetes local usando Kind com no m\u00ednimo 3 nodes; Certifique-se de que o cluster esteja pronto para receber implanta\u00e7\u00f5es.","title":"5. Crie um cluster Kubernetes"},{"location":"resolution/#6-realize-a-instalacao-do-kubernetes-dashboard-no-seu-cluster","text":"Voc\u00ea tamb\u00e9m precisar\u00e1 criar uma service-account e um cluster-role-binding ; Crie um token de acesso para a dashboard.","title":"6. Realize a instala\u00e7\u00e3o do Kubernetes Dashboard no seu cluster"},{"location":"resolution/#7-empacote-sua-aplicacao-utilizando-helm","text":"Crie um Chart Helm para o deploy da sua aplica\u00e7\u00e3o, e configure os valores padr\u00e3o no arquivo values.yaml ; Lembre de manter o pod do banco de dados separado do pod da aplica\u00e7\u00e3o; utilize o par\u00e2metro --set ao instalar o chart helm para sobrescrever vari\u00e1veis sens\u00edveis do arquivo values.yaml ; Persista suas vari\u00e1veis atrav\u00e9s de secrets e configMaps ; Crie services para sua aplica\u00e7\u00e3o e banco; Crie um namespace para a sua aplica\u00e7\u00e3o","title":"7.  Empacote sua aplica\u00e7\u00e3o utilizando Helm"},{"location":"resolution/#8-teste-sua-aplicacao-usando-helm","text":"Fa\u00e7a uma pequena altera\u00e7\u00e3o na sua aplica\u00e7\u00e3o e fa\u00e7a update na implanta\u00e7\u00e3o usando o Helm Fa\u00e7a alguns testes utilizando a estrat\u00e9gia de deployment Recreate e RollingUpdate","title":"8. Teste sua aplica\u00e7\u00e3o usando Helm"},{"location":"resolution/#9-teste-a-escalabilidade","text":"Adicione escalabilidade horizontal criando novas replicas e um (HPA) para sua implanta\u00e7\u00e3o Adicione escalabilidade vertical definindo valores de request e limite para os resources da sua implanta\u00e7\u00e3o (HPA) - Horizontal Pod autoscaler","title":"9. Teste a escalabilidade"},{"location":"resolution/#10-execute-um-registry-localmente","text":"Crie um registry local utilizando Harbor ou Distribution Suba suas imagens para este registry e utilize-as no helm","title":"10. Execute um Registry localmente"}]}